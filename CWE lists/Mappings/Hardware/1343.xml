<?xml version="1.0" encoding="UTF-8"?>
<Weakness_Catalog xmlns="http://cwe.mitre.org/cwe-7" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" Name="VIEW LIST: CWE-1343: Weaknesses in the 2021 CWE Most Important Hardware Weaknesses List" Version="4.14" Date="2024-02-29" xsi:schemaLocation="http://cwe.mitre.org/cwe-7 http://cwe.mitre.org/data/xsd/cwe_schema_v7.1.xsd">
   <Weaknesses>
      <Weakness ID="1189" Name="Improper Isolation of Shared Resources on System-on-a-Chip (SoC)" Abstraction="Base" Structure="Simple" Status="Stable">
         <Description>The System-On-a-Chip (SoC) does not properly isolate shared resources between trusted and untrusted agents.</Description>
         <Extended_Description>
            <xhtml:p>A System-On-a-Chip (SoC) has a lot of functionality, but it may have a limited number of pins or pads. A pin can only perform one function at a time. However, it can be configured to perform multiple different functions. This technique is called pin multiplexing. Similarly, several resources on the chip may be shared to multiplex and support different features or functions. When such resources are shared between trusted and untrusted agents, untrusted agents may be able to access the assets intended to be accessed only by the trusted agents.</xhtml:p>
         </Extended_Description>
         <Related_Weaknesses>
	   <Related_Weakness Nature="ChildOf" CWE_ID="653" View_ID="1000" Ordinal="Primary"/>
           <Related_Weakness Nature="ChildOf" CWE_ID="668" View_ID="1000"/>
	   <Related_Weakness Nature="PeerOf" CWE_ID="1331" View_ID="1000"/>
         </Related_Weaknesses>
	 <Weakness_Ordinalities>
            <Weakness_Ordinality>
               <Ordinality>Primary</Ordinality>
            </Weakness_Ordinality>
		 </Weakness_Ordinalities>
         <Applicable_Platforms>
            <Language Class="Not Language-Specific" Prevalence="Undetermined"/>
            <Technology Class="System on Chip" Prevalence="Undetermined"/>
         </Applicable_Platforms>
         <Modes_Of_Introduction>
            <Introduction>
               <Phase>Architecture and Design</Phase>
            </Introduction>
            <Introduction>
               <Phase>Implementation</Phase>
            </Introduction>
         </Modes_Of_Introduction>
         <Common_Consequences>
            <Consequence>
               <Scope>Access Control</Scope>
               <Impact>Bypass Protection Mechanism</Impact>
               <Note>If resources being used by a trusted user are shared with an untrusted user, the untrusted user may be able to modify the functionality of the shared resource of the trusted user.</Note>
            </Consequence>
            <Consequence>
               <Scope>Integrity</Scope>
               <Impact>Quality Degradation</Impact>
               <Note>The functionality of the shared resource may be intentionally degraded.</Note>
            </Consequence>
         </Common_Consequences>
         <Detection_Methods>
            <Detection_Method>
               <Method>Automated Dynamic Analysis</Method>
               <Description>
                  <xhtml:p>Pre-silicon / post-silicon: Test access to shared systems resources (memory ranges, control registers, etc.) from untrusted software to verify that the assets are not incorrectly exposed to untrusted agents. Note that access to shared resources can be dynamically allowed or revoked based on system flows. Security testing should cover such dynamic shared resource allocation and access control modification flows.</xhtml:p>
               </Description>
               <Effectiveness>High</Effectiveness>
            </Detection_Method>
         </Detection_Methods>
         <Potential_Mitigations>
            <Mitigation>
               <Phase>Architecture and Design</Phase>
               <Strategy>Separation of Privilege</Strategy>
               <Description>
                 <xhtml:p>When sharing resources, avoid mixing agents of varying trust levels.</xhtml:p>
                 <xhtml:p>Untrusted agents should not share resources with trusted agents.</xhtml:p>
               </Description>
            </Mitigation>
         </Potential_Mitigations>
         <Demonstrative_Examples>
            <Demonstrative_Example>
	      <Intro_Text>Consider the following SoC
	      design. The Hardware Root of Trust (HRoT) local SRAM is memory mapped in the core{0-N}
	      address space. The HRoT allows or disallows access to private memory ranges, thus
	      allowing the sram to function as a mailbox for communication between untrusted and
	      trusted HRoT partitions.</Intro_Text>
	    <Body_Text>
	    <xhtml:img src="https://cwe.mitre.org/data/images/HRoT-CWE.png" alt="Hardware Root of Trust"/>
	    <xhtml:p>
	      We assume that the threat is from malicious software in
	      the untrusted domain. We assume this software has access
	      to the core{0-N} memory map and can be running at any
	      privilege level on the untrusted cores. The capability
	      of this threat in this example is communication to and
	      from the mailbox region of SRAM modulated by the
	      hrot_iface. To address this threat, information must not
	      enter or exit the shared region of SRAM through
	      hrot_iface when in secure or privileged mode.
	      </xhtml:p>
	    </Body_Text>
            </Demonstrative_Example>
          </Demonstrative_Examples>
	  <Observed_Examples>
	    <Observed_Example>
	      <Reference>CVE-2020-8698</Reference>
	      <Description>Processor has improper isolation of shared resources allowing for information disclosure.</Description>
	      <Link>https://www.cve.org/CVERecord?id=CVE-2020-8698</Link>
	    </Observed_Example>
	    <Observed_Example>
	      <Reference>CVE-2019-6260</Reference>
	      <Description>Baseboard Management Controller (BMC) device implements Advanced High-performance Bus (AHB) bridges that do not require authentication for arbitrary read and write access to the BMC's physical address space from the host, and possibly the network [REF-1138].</Description>
	      <Link>https://www.cve.org/CVERecord?id=CVE-2019-6260</Link>
	    </Observed_Example>
	  </Observed_Examples>
         <Related_Attack_Patterns>
            <Related_Attack_Pattern CAPEC_ID="124"/>
         </Related_Attack_Patterns>
         <References>
            <Reference External_Reference_ID="REF-1036"/>
	    <Reference External_Reference_ID="REF-1138"/>
         </References>
         <Mapping_Notes>
            <Usage>Allowed</Usage>
            <Rationale>This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.</Rationale>
            <Comments>Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.</Comments>
            <Reasons>
               <Reason Type="Acceptable-Use"/>
            </Reasons>
         </Mapping_Notes>
         <Content_History>
            <Submission>
			   <Submission_Name>Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi</Submission_Name>
               <Submission_Organization>Intel Corporation</Submission_Organization>
               <Submission_Date>2019-10-15</Submission_Date>
               <Submission_Version>4.0</Submission_Version>
               <Submission_ReleaseDate>2020-02-24</Submission_ReleaseDate>
            </Submission>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-08-20</Modification_Date>
					<Modification_Comment>updated Common_Consequences, Description, Name, Potential_Mitigations, Related_Attack_Patterns, Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-12-10</Modification_Date>
					<Modification_Comment>updated Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-07-20</Modification_Date>
					<Modification_Comment>updated Demonstrative_Examples</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-10-28</Modification_Date>
					<Modification_Comment>updated Description, Observed_Examples, References, Relationships, Weakness_Ordinalities</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2022-10-13</Modification_Date>
					<Modification_Comment>updated Detection_Factors</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-04-27</Modification_Date>
					<Modification_Comment>updated Observed_Examples, Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-06-29</Modification_Date>
					<Modification_Comment>updated Mapping_Notes, Relationships</Modification_Comment>
				</Modification>
            <Contribution Type="Content">
               <Contribution_Organization>Tortuga Logic</Contribution_Organization>
               <Contribution_Date>2021-07-16</Contribution_Date>
               <Contribution_Comment>Provided Demonstrative Example for Hardware Root of Trust</Contribution_Comment>
            </Contribution>
	    <Contribution Type="Content">
	      <Contribution_Name>Hareesh Khattri</Contribution_Name>
	      <Contribution_Organization>Intel Corporation</Contribution_Organization>
	      <Contribution_Date>2021-10-22</Contribution_Date>
	      <Contribution_Comment>provided observed example</Contribution_Comment>
	    </Contribution>
	    <Contribution Type="Content">
	      <Contribution_Name>Hareesh Khattri</Contribution_Name>
	      <Contribution_Organization>Intel Corporation</Contribution_Organization>
	      <Contribution_Date>2022-04-18</Contribution_Date>
	      <Contribution_Comment>changed detection method</Contribution_Comment>
	    </Contribution>
			<Previous_Entry_Name Date="2020-08-20">Improper Isolation of Shared Resources on System-on-Chip (SoC)</Previous_Entry_Name>
         </Content_History>
      </Weakness>
      <Weakness ID="1191" Name="On-Chip Debug and Test Interface With Improper Access Control" Abstraction="Base" Structure="Simple" Status="Stable">
     <Description>The chip does not implement or does not correctly perform access control to check whether users are authorized to access internal registers and test modes through the physical debug/test interface.</Description>
     <Extended_Description>
      <xhtml:p>A device's internal information may be accessed through a scan chain of interconnected internal registers, usually through a JTAG interface. The JTAG interface provides access to these registers in a serial fashion in the form of a scan chain for the purposes of debugging programs running on a device. Since almost all information contained within a device may be accessed over this interface, device manufacturers typically insert some form of authentication and authorization to prevent unintended use of this sensitive information. This mechanism is implemented in addition to on-chip protections that are already present.</xhtml:p>
      <xhtml:p>If authorization, authentication, or some other form of access control is not implemented or not implemented correctly, a user may be able to bypass on-chip protection mechanisms through the debug interface.</xhtml:p>
      <xhtml:p>Sometimes, designers choose not to expose the debug pins on the motherboard. Instead, they choose to hide these pins in the intermediate layers of the board. This is primarily done to work around the lack of debug authorization inside the chip. In such a scenario (without debug authorization), when the debug interface is exposed, chip internals are accessible to an attacker.</xhtml:p>
     </Extended_Description>
     <Related_Weaknesses>
      <Related_Weakness Nature="ChildOf" CWE_ID="284" View_ID="1000" Ordinal="Primary"/>
     </Related_Weaknesses>
		 <Weakness_Ordinalities>
            <Weakness_Ordinality>
               <Ordinality>Primary</Ordinality>
            </Weakness_Ordinality>
		 </Weakness_Ordinalities>
     <Applicable_Platforms>
      <Language Class="Not Language-Specific" Prevalence="Undetermined"/>
      <Operating_System Class="Not OS-Specific" Prevalence="Undetermined"/>
      <Architecture Class="Not Architecture-Specific" Prevalence="Undetermined"/>
      <Technology Class="Not Technology-Specific" Prevalence="Undetermined"/>
     </Applicable_Platforms>
     <Modes_Of_Introduction>
      <Introduction>
        <Phase>Architecture and Design</Phase>
      </Introduction>
      <Introduction>
        <Phase>Implementation</Phase>
      </Introduction>
     </Modes_Of_Introduction>
     <Common_Consequences>
      <Consequence>
        <Scope>Confidentiality</Scope>
        <Impact>Read Application Data</Impact>
			  <Likelihood>High</Likelihood>
      </Consequence>
      <Consequence>
        <Scope>Confidentiality</Scope>
        <Impact>Read Memory</Impact>
			  <Likelihood>High</Likelihood>
      </Consequence>
      <Consequence>
        <Scope>Authorization</Scope>
        <Impact>Execute Unauthorized Code or Commands</Impact>
			  <Likelihood>High</Likelihood>
      </Consequence>
      <Consequence>
        <Scope>Integrity</Scope>
        <Impact>Modify Memory</Impact>
			  <Likelihood>High</Likelihood>
      </Consequence>
      <Consequence>
        <Scope>Integrity</Scope>
        <Impact>Modify Application Data</Impact>
			  <Likelihood>High</Likelihood>
      </Consequence>
      <Consequence>
        <Scope>Access Control</Scope>
        <Impact>Bypass Protection Mechanism</Impact>
			  <Likelihood>High</Likelihood>
      </Consequence>
     </Common_Consequences>
     <Detection_Methods>
       <Detection_Method>
	 <Method>Dynamic Analysis with Manual Results Interpretation</Method>
	 <Description><xhtml:p>Authentication and authorization of debug and test interfaces should be part of the architecture and design review process. Withholding of private register documentation from the debug and test interface public specification ("Security by obscurity") should not be considered as sufficient security.</xhtml:p></Description>
       </Detection_Method>
       <Detection_Method>
	 <Method>Dynamic Analysis with Manual Results Interpretation</Method>
	 <Description><xhtml:p>Dynamic tests should be done in the pre-silicon and post-silicon stages to verify that the debug and test interfaces are not open by default.</xhtml:p></Description>
       </Detection_Method>
       <Detection_Method>
	 <Method>Fuzzing</Method>
	 <Description>Tests that fuzz Debug and Test Interfaces should ensure that no access without appropriate authentication and authorization is possible.</Description>
	 <Effectiveness>Moderate</Effectiveness>
       </Detection_Method>
     </Detection_Methods>
     <Potential_Mitigations>
       <Mitigation>
	 <Phase>Architecture and Design</Phase>
	 <Strategy>Separation of Privilege</Strategy>
	 <Description>
	   If feasible, the manufacturer should disable the JTAG interface or implement authentication and authorization for the JTAG interface. If authentication logic is added, it should be resistant to timing attacks. Security-sensitive data stored in registers, such as keys, etc. should be cleared when entering debug mode.
	 </Description>
	 <Effectiveness>High</Effectiveness>
       </Mitigation>
     </Potential_Mitigations>
    <Demonstrative_Examples>
<Demonstrative_Example>
        <Intro_Text>A home, WiFi-router device implements a login prompt which prevents an unauthorized user from issuing any commands on the device until appropriate credentials are provided. The credentials are protected on the device and are checked for strength against attack.</Intro_Text>
        <Example_Code Nature="Bad" Language="Other">
	  <xhtml:p>If the JTAG interface on this device is not hidden by the manufacturer, the interface may be identified using tools such as JTAGulator. If it is hidden but not disabled, it can be exposed by physically wiring to the board.</xhtml:p>
	  <xhtml:p>By issuing a "halt" command before the OS starts, the unauthorized user pauses the watchdog timer and prevents the router from restarting (once the watchdog timer would have expired). Having paused the router, an unauthorized user is able to execute code and inspect and modify data in the device, even extracting all of the router's firmware. This allows the user to examine the router and potentially exploit it.</xhtml:p>
	</Example_Code>
	<Body_Text>JTAG is useful to chip and device manufacturers during design, testing, and production and is included in nearly every product. Without proper authentication and authorization, the interface may allow tampering with a product.</Body_Text>
	<Example_Code Nature="Good" Language="Other">In order to prevent exposing the debugging interface, manufacturers might try to obfuscate the JTAG interface or blow device internal fuses to disable the JTAG interface. Adding authentication and authorization to this interface makes use by unauthorized individuals much more difficult.</Example_Code>
    </Demonstrative_Example>
	<Demonstrative_Example>
		<Intro_Text>The following example code is a snippet from the JTAG wrapper module in the RISC-V debug module of the HACK@DAC'21 Openpiton SoC [REF-1355]. To make sure that the JTAG is accessed securely, the developers have included a primary authentication mechanism based on a password.</Intro_Text>
		<Body_Text>The developers employed a Finite State Machine (FSM) to implement this authentication. When a user intends to read from or write to the JTAG module, they must input a password.</Body_Text>
		<Body_Text>In the subsequent state of the FSM module, the entered password undergoes Hash-based Message Authentication Code (HMAC) calculation using an internal HMAC submodule. Once the HMAC for the entered password is computed by the HMAC submodule, the FSM transitions to the next state, where it compares the computed HMAC with the expected HMAC for the password.</Body_Text>
		<Body_Text>If the computed HMAC matches the expected HMAC, the FSM grants the user permission to perform read or write operations on the JTAG module. [REF-1352]</Body_Text>
		<Example_Code Nature="Bad" Language="Verilog">
			<xhtml:div>...<xhtml:br/>
			<xhtml:div style="margin-left:1em;">PassChkValid: begin<xhtml:br/>
				<xhtml:div style="margin-left:1em;">if(hashValid) begin<xhtml:br/>
					<xhtml:div style="margin-left:1em;"><xhtml:b>if(exp_hash == pass_hash) begin</xhtml:b><xhtml:br/>
						<xhtml:div style="margin-left:1em;"><xhtml:b>pass_check = 1'b1;</xhtml:b></xhtml:div>
						<xhtml:b>end else begin</xhtml:b>
						<xhtml:div style="margin-left:1em;"><xhtml:b>pass_check = 1'b0;</xhtml:b></xhtml:div>
						<xhtml:b>end<xhtml:br/>
						state_d = Idle;</xhtml:b>
						</xhtml:div>
					end else begin
						<xhtml:div style="margin-left:1em;">state_d = PassChkValid;</xhtml:div>
					end</xhtml:div>
				end</xhtml:div>
			...</xhtml:div>
		</Example_Code>
		<Body_Text>However, in the given vulnerable part of the code, the JTAG module has not defined a limitation for several continuous wrong password attempts. This omission poses a significant security risk, allowing attackers to carry out brute-force attacks without restrictions.</Body_Text>
		<Body_Text>Without a limitation on wrong password attempts, an attacker can repeatedly guess different passwords until they gain unauthorized access to the JTAG module. This leads to various malicious activities, such as unauthorized read from or write to debug module interface.</Body_Text>
		<Body_Text>To mitigate the mentioned vulnerability, developers need to implement a restriction on the number of consecutive incorrect password attempts allowed by the JTAG module, which can achieve by incorporating a mechanism that temporarily locks the module after a certain number of failed attempts.[REF-1353][REF-1354]</Body_Text>
		<Example_Code Nature="Good" Language="Verilog">
			<xhtml:div>...<xhtml:br/>
			case (state_q)
				<xhtml:div style="margin-left:1em;">Idle: begin<xhtml:br/>
				...
					<xhtml:div style="margin-left:1em;">else if ( (dm::dtm_op_e'(dmi.op) == dm::DTM_PASS) &amp;&amp; <xhtml:b>(miss_pass_check_cnt_q != 2'b11)</xhtml:b> )<xhtml:br/>
					begin
						<xhtml:div style="margin-left:1em;">state_d = Write;<xhtml:br/>pass_mode = 1'b1;</xhtml:div>
					end</xhtml:div>
				...<xhtml:br/>
				end<xhtml:br/>
				...</xhtml:div>
				<xhtml:div style="margin-left:1em;">PassChkValid: begin<xhtml:br/>
					<xhtml:div style="margin-left:1em;">if(hashValid) begin<xhtml:br/>
						<xhtml:div style="margin-left:1em;">if(exp_hash == pass_hash) begin<xhtml:br/>
							<xhtml:div style="margin-left:1em;">pass_check = 1'b1;</xhtml:div>
							end else begin
							<xhtml:div style="margin-left:1em;">pass_check = 1'b0;<xhtml:br/>
							<xhtml:b>miss_pass_check_cnt_d = miss_pass_check_cnt_q + 1</xhtml:b>
							</xhtml:div>
							end<xhtml:br/>
							state_d = Idle;
							</xhtml:div>
						end else begin
							<xhtml:div style="margin-left:1em;">state_d = PassChkValid;</xhtml:div>
						end</xhtml:div>
					end</xhtml:div>
				...</xhtml:div>
		</Example_Code>
	</Demonstrative_Example>
	<Demonstrative_Example>
		<Intro_Text>The example code below is taken from the JTAG access control mechanism of the HACK@DAC'21 buggy OpenPiton SoC [REF-1364]. Access to JTAG allows users to access sensitive information in the system. Hence, access to JTAG is controlled using cryptographic authentication of the users. In this example (see the vulnerable code source), the password checker uses HMAC-SHA256 for authentication. It takes a 512-bit secret message from the user, hashes it using HMAC, and compares its output with the expected output to determine the authenticity of the user.</Intro_Text>
		<Example_Code Nature="Bad" Language="Verilog">
		...<xhtml:br/>
		<xhtml:b>logic [31-1:0] data_d,</xhtml:b> data_q;<xhtml:br/>
		...<xhtml:br/>
		<xhtml:b>logic [512-1:0] pass_data;</xhtml:b><xhtml:br/>
		...<xhtml:br/>
			<xhtml:div style="margin-left:1em;">
			Write: begin<xhtml:br/>
				<xhtml:div style="margin-left:1em;">
				...<xhtml:br/>
					<xhtml:div style="margin-left:1em;">
					if (pass_mode) begin<xhtml:br/>
						<xhtml:div style="margin-left:1em;">
							<xhtml:b>pass_data = { {60{8'h00}}, data_d};</xhtml:b><xhtml:br/>
							state_d = PassChk;<xhtml:br/>
							pass_mode = 1'b0;<xhtml:br/>
						</xhtml:div>
					...<xhtml:br/>
					</xhtml:div>
				</xhtml:div>
			end<xhtml:br/>
			</xhtml:div>
		...<xhtml:br/>
		</Example_Code>
		<Body_Text>The vulnerable code shows an incorrect implementation of the HMAC authentication where it only uses the least significant 32 bits of the secret message for the authentication (the remaining 480 bits are hard coded as zeros). As a result, the system is susceptible to brute-force attacks on the access control mechanism of JTAG, where the attacker only needs to determine 32 bits of the secret message instead of 512 bits.</Body_Text>
		<Body_Text>To mitigate this issue, remove the zero padding and use all 512 bits of the secret message for HMAC authentication [REF-1365].</Body_Text>
		<Example_Code Nature="Good" Language="Verilog">
		...<xhtml:br/>
		<xhtml:b>logic [512-1:0] data_d,</xhtml:b> data_q;<xhtml:br/>
		...<xhtml:br/>
		logic [512-1:0] pass_data;<xhtml:br/>
		...<xhtml:br/>
			<xhtml:div style="margin-left:1em;">
			Write: begin<xhtml:br/>
				<xhtml:div style="margin-left:1em;">
				...<xhtml:br/>
					<xhtml:div style="margin-left:1em;">
					if (pass_mode) begin<xhtml:br/>
						<xhtml:div style="margin-left:1em;">
							<xhtml:b>pass_data = data_d;</xhtml:b><xhtml:br/>
							state_d = PassChk;<xhtml:br/>
							pass_mode = 1'b0;<xhtml:br/>
						</xhtml:div>
					...<xhtml:br/>
					</xhtml:div>
				</xhtml:div>
			end<xhtml:br/>
			</xhtml:div>
		...<xhtml:br/>
		</Example_Code>
	</Demonstrative_Example>
    </Demonstrative_Examples>
     <Observed_Examples>
      <Observed_Example>
       <Reference>CVE-2019-18827</Reference>
       <Description>chain: JTAG interface is not disabled (CWE-1191) during ROM code execution, introducing a race condition (CWE-362) to extract encryption keys</Description>
       <Link>https://www.cve.org/CVERecord?id=CVE-2019-18827</Link>
      </Observed_Example>
     </Observed_Examples>
         <Related_Attack_Patterns>
            <Related_Attack_Pattern CAPEC_ID="1"/>
            <Related_Attack_Pattern CAPEC_ID="180"/>
         </Related_Attack_Patterns>
         <References>
      <Reference External_Reference_ID="REF-1037"/>
      <Reference External_Reference_ID="REF-1043"/>
      <Reference External_Reference_ID="REF-1084"/>
      <Reference External_Reference_ID="REF-1085"/>
	  <Reference External_Reference_ID="REF-1355"/>
	  <Reference External_Reference_ID="REF-1354"/>
	  <Reference External_Reference_ID="REF-1353"/>
	  <Reference External_Reference_ID="REF-1352"/>
	  <Reference External_Reference_ID="REF-1364"/>
	  <Reference External_Reference_ID="REF-1365"/>
     </References>
         <Mapping_Notes>
            <Usage>Allowed</Usage>
            <Rationale>This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.</Rationale>
            <Comments>Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.</Comments>
            <Reasons>
               <Reason Type="Acceptable-Use"/>
            </Reasons>
         </Mapping_Notes>
      <Notes>
	<Note Type="Relationship">
	  CWE-1191 and CWE-1244 both involve physical debug access,
	  but the weaknesses are different. CWE-1191 is effectively
	  about missing authorization for a debug interface,
	  i.e. JTAG.  CWE-1244 is about providing internal assets with
	  the wrong debug access level, exposing the asset to
	  untrusted debug agents.</Note>
      </Notes>
     <Content_History>
      <Submission>
			  <Submission_Name>Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi</Submission_Name>
        <Submission_Organization>Intel Corporation</Submission_Organization>
        <Submission_Date>2019-10-15</Submission_Date>
        <Submission_Version>4.0</Submission_Version>
        <Submission_ReleaseDate>2020-02-24</Submission_ReleaseDate>
      </Submission>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-06-25</Modification_Date>
					<Modification_Comment>updated Applicable_Platforms, Common_Consequences, Demonstrative_Examples, Description, Name, References, Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-08-20</Modification_Date>
					<Modification_Comment>updated Applicable_Platforms, Demonstrative_Examples, Description, Name, Potential_Mitigations, Related_Attack_Patterns, Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-03-15</Modification_Date>
					<Modification_Comment>updated Maintenance_Notes</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-10-28</Modification_Date>
					<Modification_Comment>updated Demonstrative_Examples, Description, Detection_Factors, Maintenance_Notes, Name, Potential_Mitigations, Relationship_Notes, Relationships, Weakness_Ordinalities</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2022-04-28</Modification_Date>
					<Modification_Comment>updated Related_Attack_Patterns</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2022-10-13</Modification_Date>
					<Modification_Comment>updated Description, Related_Attack_Patterns</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-04-27</Modification_Date>
					<Modification_Comment>updated References, Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-06-29</Modification_Date>
					<Modification_Comment>updated Mapping_Notes</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-10-26</Modification_Date>
					<Modification_Comment>updated Demonstrative_Examples, References</Modification_Comment>
				</Modification>
				<Contribution Type="Content">
				  <Contribution_Name>Parbati K. Manna</Contribution_Name>
				  <Contribution_Organization>Intel Corporation</Contribution_Organization>
				  <Contribution_Date>2021-10-18</Contribution_Date>
				  <Contribution_Comment>provided detection methods</Contribution_Comment>
				</Contribution>
				<Contribution Type="Feedback">
				  <Contribution_Name>Narasimha Kumar V Mangipudi</Contribution_Name>
				  <Contribution_Organization>Lattice Semiconductor</Contribution_Organization>
				  <Contribution_Date>2021-10-20</Contribution_Date>
				  <Contribution_Comment>reviewed content changes</Contribution_Comment>
				</Contribution>
				<Contribution Type="Content">
				  <Contribution_Name>Hareesh Khattri</Contribution_Name>
				  <Contribution_Organization>Intel Corporation</Contribution_Organization>
				  <Contribution_Date>2021-10-22</Contribution_Date>
				  <Contribution_Comment>clarified differences between CWE-1191 and CWE-1244</Contribution_Comment>
				</Contribution>
				<Contribution Type="Content">
				  <Contribution_Name>Arun Kanuparthi</Contribution_Name>
				  <Contribution_Organization>Intel Corporation</Contribution_Organization>
				  <Contribution_Date>2021-10-27</Contribution_Date>
				  <Contribution_Comment>suggested additional detail in extended description</Contribution_Comment>
				</Contribution>
				<Contribution Type="Content">
				  <Contribution_Name>Shaza Zeitouni, Mohamadreza Rostami, Pouya Mahmoody, Ahmad-Reza Sadeghi</Contribution_Name>
				  <Contribution_Organization>Technical University of Darmstadt</Contribution_Organization>
				  <Contribution_Date>2023-06-21</Contribution_Date>
				  <Contribution_Comment>suggested demonstrative example</Contribution_Comment>
				</Contribution>
				<Contribution Type="Content">
				  <Contribution_Name>Rahul Kande, Chen Chen, Jeyavijayan Rajendran</Contribution_Name>
				  <Contribution_Organization>Texas A&amp;M University</Contribution_Organization>
				  <Contribution_Date>2023-06-21</Contribution_Date>
				  <Contribution_Comment>suggested demonstrative example</Contribution_Comment>
				</Contribution>
			<Previous_Entry_Name Date="2020-02-26">Exposed Chip Debug Interface With Insufficient Access Control</Previous_Entry_Name>
			<Previous_Entry_Name Date="2020-08-20">Exposed Chip Debug and or Test Interface With Insufficient Access Control</Previous_Entry_Name>
			<Previous_Entry_Name Date="2021-10-28">Exposed Chip Debug and Test Interface With Insufficient or Missing Authorization</Previous_Entry_Name>
     </Content_History>
   </Weakness>
      <Weakness ID="1231" Name="Improper Prevention of Lock Bit Modification" Abstraction="Base" Structure="Simple" Status="Stable">
            <Description>The product uses a trusted lock bit for restricting access to registers, address regions, or other resources, but the product does not prevent the value of the lock bit from being modified after it has been set.</Description>
			<Extended_Description>
			  <xhtml:p>In integrated circuits and hardware
			  intellectual property (IP) cores, device configuration
			  controls are commonly programmed after a device power
			  reset by a trusted firmware or software module (e.g.,
			  BIOS/bootloader) and then locked from any further
			  modification.</xhtml:p>

			  <xhtml:p>This behavior is commonly implemented using a trusted lock bit. 
			  When set, the lock bit disables writes to a protected set of
			  registers or address regions. Design or coding errors in
			  the implementation of the lock bit protection feature
			  may allow the lock bit to be modified or cleared by
			  software after it has been set. Attackers might be able to unlock the system and
			  features that the bit is intended to protect.</xhtml:p>
			</Extended_Description>
			<Related_Weaknesses>
				<Related_Weakness Nature="ChildOf" CWE_ID="284" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
		 <Weakness_Ordinalities>
            <Weakness_Ordinality>
               <Ordinality>Primary</Ordinality>
            </Weakness_Ordinality>
		 </Weakness_Ordinalities>
            <Applicable_Platforms>
                <Language Class="Not Language-Specific" Prevalence="Undetermined"/>
                <Operating_System Class="Not OS-Specific" Prevalence="Undetermined"/>
                <Architecture Class="Not Architecture-Specific" Prevalence="Undetermined"/>
                <Technology Class="Not Technology-Specific" Prevalence="Undetermined"/>
            </Applicable_Platforms>
            <Modes_Of_Introduction>
                <Introduction>
                    <Phase>Architecture and Design</Phase>
                    <Note>Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases.</Note>
                </Introduction>
                <Introduction>
                    <Phase>Implementation</Phase>
                    <Note>Such issues could be introduced during implementation and identified later during Testing or System Configuration phases.</Note>
                </Introduction>
            </Modes_Of_Introduction>
            <Common_Consequences>
                <Consequence>
                    <Scope>Access Control</Scope>
                    <Impact>Modify Memory</Impact>
                    <Likelihood>High</Likelihood>
                    <Note>Registers protected by lock bit can be modified even when lock is set.</Note>
                </Consequence>
            </Common_Consequences>
	 <Detection_Methods>
	   <Detection_Method>
	     <Method>Manual Analysis</Method>
	     <Description>Set the lock bit. Power cycle the
	     device. Attempt to clear the lock bit.  If the
	     information is changed, implement a design
	     fix. Retest. Also, attempt to indirectly clear the lock
	     bit or bypass it.</Description>
	     <Effectiveness>High</Effectiveness>
	   </Detection_Method>
	 </Detection_Methods>
            <Potential_Mitigations>
                <Mitigation>
                    <Phase>Architecture and Design</Phase>
                    <Phase>Implementation</Phase>
                    <Phase>Testing</Phase>
                    <Description>
                        <xhtml:ul>
                            <xhtml:li>Security lock bit protections must be reviewed for design inconsistency and common weaknesses.</xhtml:li>
                            <xhtml:li>Security lock programming flow and lock properties must be tested in pre-silicon and post-silicon testing.</xhtml:li>
                        </xhtml:ul>
                    </Description>
                    <Effectiveness>High</Effectiveness>
                </Mitigation>
            </Potential_Mitigations>
            <Demonstrative_Examples>
                <Demonstrative_Example>
                    <Intro_Text>Consider the example design below for a digital thermal sensor that detects overheating of the silicon and triggers system shutdown. The system critical temperature limit (CRITICAL_TEMP_LIMIT) and thermal sensor calibration (TEMP_SENSOR_CALIB) data have to be programmed by firmware, and then the register needs to be locked (TEMP_SENSOR_LOCK).</Intro_Text>
                    <Example_Code Nature="Bad" Language="Other">
                        <xhtml:table>
                            <xhtml:tr>
                                <xhtml:th>Register</xhtml:th>
                                <xhtml:th>Field description</xhtml:th>
                            </xhtml:tr>
                            <xhtml:tr>
                                <xhtml:td>CRITICAL_TEMP_LIMIT</xhtml:td>
                                <xhtml:td>[31:8] Reserved field; Read only; Default 0<xhtml:br/>[7:0] Critical temp 0-255 Centigrade; Read-write-lock; Default 125</xhtml:td>
                            </xhtml:tr>
                            <xhtml:tr>
                                <xhtml:td>TEMP_SENSOR_CALIB</xhtml:td>
                                <xhtml:td>[31:0] Thermal sensor calibration data. Slope value used to map sensor reading to degrees Centigrade.</xhtml:td>
                            </xhtml:tr>
                            <xhtml:tr>
                                <xhtml:td>TEMP_SENSOR_LOCK</xhtml:td>
                                <xhtml:td>[31:1] Reserved field; Read only; Default 0<xhtml:br/>[0] Lock bit, locks CRITICAL_TEMP_LIMIT and TEMP_SENSOR_CALIB registers; Write-1-once; Default 0</xhtml:td>
                            </xhtml:tr>
                            <xhtml:tr>
                                <xhtml:td>TEMP_HW_SHUTDOWN</xhtml:td>
                                <xhtml:td>[31:2] Reserved field; Read only; Default 0<xhtml:br/>[1] Enable hardware shutdown on critical temperature detection; Read-write; Default 0</xhtml:td>
                            </xhtml:tr>
                            <xhtml:tr>
                                <xhtml:td>CURRENT_TEMP</xhtml:td>
                                <xhtml:td>[31:8] Reserved field; Read only; Default 0<xhtml:br/>[7:0] Current Temp 0-255 Centigrade; Read-only; Default 0</xhtml:td>
                            </xhtml:tr>
                        </xhtml:table>
                    </Example_Code>
                    <Body_Text>In this example, note that if the system heats to critical temperature, the response of the system is controlled by the TEMP_HW_SHUTDOWN bit [1], which is not lockable. Thus, the intended security property of the critical temperature sensor cannot be fully protected, since software can misconfigure the TEMP_HW_SHUTDOWN register even after the lock bit is set to disable the shutdown response.</Body_Text>
                    <Example_Code Nature="Good">
                        <xhtml:p>To fix this weakness, one could change the TEMP_HW_SHUTDOWN field to be locked by TEMP_SENSOR_LOCK.</xhtml:p>
                        <xhtml:table>
                            <xhtml:tr>
                                <xhtml:td>TEMP_HW_SHUTDOWN</xhtml:td>
                                <xhtml:td>[31:2] Reserved field; Read only; Default 0 <xhtml:br/>[1] Enable hardware shutdown on critical temperature detection; Read-write-Lock; Default 0<xhtml:br/>[0] Locked by TEMP_SENSOR_LOCK</xhtml:td>
                            </xhtml:tr>
                        </xhtml:table>
                    </Example_Code>
                </Demonstrative_Example>
                <Demonstrative_Example>
                    <Intro_Text>The following example code is a snippet from the register locks inside the buggy OpenPiton SoC of HACK@DAC'21 [REF-1350]. Register locks help prevent SoC peripherals' registers from malicious use of resources. The registers that can potentially leak secret data are locked by register locks.</Intro_Text>
                    <Body_Text>In the vulnerable code, the reglk_mem is used for locking information. If one of its bits toggle to 1, the corresponding peripheral's registers will be locked. In the context of the HACK@DAC System-on-Chip (SoC), it is pertinent to note the existence of two distinct categories of reset signals.</Body_Text>
                    <Body_Text>First, there is a global reset signal denoted as "rst_ni," which possesses the capability to simultaneously reset all peripherals to their respective initial states.</Body_Text>
                    <Body_Text>Second, we have peripheral-specific reset signals, such as "rst_9," which exclusively reset individual peripherals back to their initial states. The administration of these reset signals is the responsibility of the reset controller module.</Body_Text>
                    <Example_Code Nature="Bad" Language="Verilog">
                            <xhtml:div style="margin-left:1em;">always @(posedge clk_i)<xhtml:br/>
                                <xhtml:div style="margin-left:1em;">begin<xhtml:br/>
                                    <xhtml:div style="margin-left:1em;"><xhtml:b>if(~(rst_ni &amp;&amp; ~jtag_unlock &amp;&amp; ~rst_9))</xhtml:b><xhtml:br/>
										<xhtml:div style="margin-left:1em;">begin
                                            <xhtml:div style="margin-left:1em;">for (j=0; j &lt; 6; j=j+1) begin
                                                <xhtml:div style="margin-left:1em;">reglk_mem[j] &lt;= 'h0;</xhtml:div>
                                            </xhtml:div>
                                        end</xhtml:div>
									<xhtml:br/></xhtml:div>
                                </xhtml:div>
                        	end<xhtml:br/>...</xhtml:div>
                    </Example_Code>
                    <Body_Text>In the buggy SoC architecture during HACK@DAC'21, a critical issue arises within the reset controller module. Specifically, the reset controller can inadvertently transmit a peripheral reset signal to the register lock within the user privilege domain.</Body_Text>
                    <Body_Text>This unintentional action can result in the reset of the register locks, potentially exposing private data from all other peripherals, rendering them accessible and readable.</Body_Text>
                    <Body_Text>To mitigate the issue, remove the extra reset signal rst_9 from the register lock if condition. [REF-1351]</Body_Text>
                    <Example_Code Nature="Good" Language="Verilog">
                        <xhtml:div style="margin-left:1em;">always @(posedge clk_i)<xhtml:br/>
                            <xhtml:div style="margin-left:1em;">begin<xhtml:br/>
                                <xhtml:div style="margin-left:1em;"><xhtml:b>if(~(rst_ni &amp;&amp; ~jtag_unlock))</xhtml:b><xhtml:br/>
                                    <xhtml:div style="margin-left:1em;">begin
                                        <xhtml:div style="margin-left:1em;">for (j=0; j &lt; 6; j=j+1) begin
                                            <xhtml:div style="margin-left:1em;">reglk_mem[j] &lt;= 'h0;</xhtml:div>
                                        </xhtml:div>
                                    end</xhtml:div>
                                <xhtml:br/></xhtml:div>
                            </xhtml:div>
                        end<xhtml:br/>...</xhtml:div>
                    </Example_Code>
                </Demonstrative_Example>
            </Demonstrative_Examples>
	    <Observed_Examples>
	      <Observed_Example>
		<Reference>CVE-2017-6283</Reference>
		<Description>chip reset clears critical read/write lock permissions for RSA function</Description>
		<Link>https://www.cve.org/CVERecord?id=CVE-2017-6283</Link>
	      </Observed_Example>
	    </Observed_Examples>
         <Related_Attack_Patterns>
            <Related_Attack_Pattern CAPEC_ID="680"/>
         </Related_Attack_Patterns>
         <References>
            <Reference External_Reference_ID="REF-1350"/>
            <Reference External_Reference_ID="REF-1351"/>
        </References>
        <Mapping_Notes>
            <Usage>Allowed</Usage>
            <Rationale>This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.</Rationale>
            <Comments>Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.</Comments>
            <Reasons>
               <Reason Type="Acceptable-Use"/>
            </Reasons>
         </Mapping_Notes>   
      
         <Content_History>
                <Submission>
                    <Submission_Name>Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi</Submission_Name>
                    <Submission_Organization>Intel Corporation</Submission_Organization>
                    <Submission_Date>2020-01-15</Submission_Date>
                    <Submission_Version>4.0</Submission_Version>
                    <Submission_ReleaseDate>2020-02-24</Submission_ReleaseDate>
                </Submission>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-06-25</Modification_Date>
					<Modification_Comment>updated Demonstrative_Examples</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-08-20</Modification_Date>
					<Modification_Comment>updated Related_Attack_Patterns</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-10-28</Modification_Date>
					<Modification_Comment>updated Demonstrative_Examples, Description, Detection_Factors, Name, Observed_Examples, Potential_Mitigations, Relationships, Weakness_Ordinalities</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2022-04-28</Modification_Date>
					<Modification_Comment>updated Related_Attack_Patterns, Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-04-27</Modification_Date>
					<Modification_Comment>updated Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-06-29</Modification_Date>
					<Modification_Comment>updated Mapping_Notes</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-10-26</Modification_Date>
					<Modification_Comment>updated Demonstrative_Examples, References</Modification_Comment>
				</Modification>
				<Contribution Type="Feedback">
				  <Contribution_Name>Narasimha Kumar V Mangipudi</Contribution_Name>
				  <Contribution_Organization>Lattice Semiconductor</Contribution_Organization>
				  <Contribution_Date>2021-10-20</Contribution_Date>
				  <Contribution_Comment>reviewed content changes</Contribution_Comment>
				</Contribution>
				<Contribution Type="Content">
				  <Contribution_Name>Hareesh Khattri</Contribution_Name>
				  <Contribution_Organization>Intel Corporation</Contribution_Organization>
				  <Contribution_Date>2021-10-22</Contribution_Date>
				  <Contribution_Comment>provided observed example</Contribution_Comment>
				</Contribution>
				<Contribution Type="Content">
				  <Contribution_Name>Shaza Zeitouni, Mohamadreza Rostami, Pouya Mahmoody, Ahmad-Reza Sadeghi</Contribution_Name>
				  <Contribution_Organization>Technical University of Darmstadt</Contribution_Organization>
				  <Contribution_Date>2023-06-21</Contribution_Date>
				  <Contribution_Comment>suggested demonstrative example</Contribution_Comment>
				</Contribution>
				<Contribution Type="Content">
				  <Contribution_Name>Rahul Kande, Chen Chen, Jeyavijayan Rajendran</Contribution_Name>
				  <Contribution_Organization>Texas A&amp;M University</Contribution_Organization>
				  <Contribution_Date>2023-06-21</Contribution_Date>
				  <Contribution_Comment>suggested demonstrative example</Contribution_Comment>
				</Contribution>
			<Previous_Entry_Name Date="2021-10-28">Improper Implementation of Lock Protection Registers</Previous_Entry_Name>
            </Content_History>
        </Weakness>
      <Weakness ID="1233" Name="Security-Sensitive Hardware Controls with Missing Lock Bit Protection" Abstraction="Base" Structure="Simple" Status="Stable">
         <Description>The product uses a register lock bit protection mechanism, but it does not ensure that the lock bit prevents modification of system registers or controls that perform changes to important hardware system configuration.</Description>
         <Extended_Description>
         	<xhtml:p>Integrated circuits and hardware intellectual properties (IPs) might provide device configuration controls that need to be programmed after device power reset by a trusted firmware or software module, commonly set by BIOS/bootloader. After reset, there can be an expectation that the controls cannot be used to perform any further modification. This behavior is commonly implemented using a trusted lock bit, which can be set to disable writes to a protected set of registers or address regions. The lock protection is intended to prevent modification of certain system configuration (e.g., memory/memory protection unit configuration).</xhtml:p>
		<xhtml:p>However, if the lock bit does not effectively write-protect all system registers or controls that could modify the protected system configuration, then an adversary may be able to use software to access the registers/controls and modify the protected hardware configuration.</xhtml:p>
		</Extended_Description>
			<Related_Weaknesses>
			  <Related_Weakness Nature="ChildOf" CWE_ID="284" View_ID="1000" Ordinal="Primary"/>
			  <Related_Weakness Nature="ChildOf" CWE_ID="667" View_ID="1000"/>
			</Related_Weaknesses>
		 <Weakness_Ordinalities>
            <Weakness_Ordinality>
               <Ordinality>Primary</Ordinality>
            </Weakness_Ordinality>
		 </Weakness_Ordinalities>
         <Applicable_Platforms>
            <Language Class="Not Language-Specific" Prevalence="Undetermined"/>
			<Operating_System Class="Not OS-Specific" Prevalence="Undetermined"/>
			<Architecture Class="Not Architecture-Specific" Prevalence="Undetermined"/>
			<Technology Class="Not Technology-Specific" Prevalence="Undetermined"/>
         </Applicable_Platforms>
         <Modes_Of_Introduction>
            <Introduction>
               <Phase>Architecture and Design</Phase>
               <Note>Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases.</Note>
            </Introduction>
            <Introduction>
               <Phase>Implementation</Phase>
               <Note>Such issues could be introduced during implementation and identified later during Testing or System Configuration phases.</Note>
            </Introduction>
         </Modes_Of_Introduction>
         <Common_Consequences>
            <Consequence>
               <Scope>Access Control</Scope>
			   <Impact>Modify Memory</Impact>
               <Note>System Configuration protected by the lock bit can be modified even when the lock is set.</Note>
            </Consequence>
         </Common_Consequences>
	 <Detection_Methods>
	   <Detection_Method>
	     <Method>Manual Analysis</Method>
	     <Description>Set the lock bit. Attempt to modify the
	     information protected by the lock bit. If the information
	     is changed, implement a design fix. Retest. Also, attempt
	     to indirectly clear the lock bit or bypass
	     it.</Description>
	     <Effectiveness>High</Effectiveness>
	   </Detection_Method>
	 </Detection_Methods>
         <Potential_Mitigations>
            <Mitigation>
               <Phase>Architecture and Design</Phase>
                    <Phase>Implementation</Phase>
                    <Phase>Testing</Phase>
                    <Description>
                        <xhtml:ul>
                            <xhtml:li>Security lock bit protections must be reviewed for design inconsistency and common weaknesses.</xhtml:li>
			    <xhtml:li>Security lock programming flow and lock properties must be tested in pre-silicon and post-silicon testing.</xhtml:li>
                        </xhtml:ul>
                    </Description>
            </Mitigation>
         </Potential_Mitigations>
         <Demonstrative_Examples>
            <Demonstrative_Example>
               <Intro_Text>Consider the example design below for a digital thermal sensor that detects overheating of the silicon and triggers system shutdown. The system critical temperature limit (CRITICAL_TEMP_LIMIT) and thermal sensor calibration (TEMP_SENSOR_CALIB) data have to be programmed by the firmware. 
               </Intro_Text>
               <Example_Code Nature="Bad" Language="Other">
				<xhtml:table>
				    <xhtml:tr>
				        <xhtml:th>Register</xhtml:th>
				        <xhtml:th>Field description</xhtml:th>
				    </xhtml:tr>
				<xhtml:tr>
				  <xhtml:td>CRITICAL_TEMP_LIMIT
				  </xhtml:td>
				  <xhtml:td>[31:8] Reserved field; Read only; Default 0<xhtml:br/>[7:0] Critical temp 0-255 Centigrade; Read-write-lock; Default 125
				  </xhtml:td>
				  </xhtml:tr>
				  <xhtml:tr>
				  <xhtml:td>TEMP_SENSOR_CALIB
				  </xhtml:td>
				  <xhtml:td>[31:0] Thermal sensor calibration data. A slope value used to map sensor reading to a degree Centigrade. Read-write; Default 25
				  </xhtml:td>
				  </xhtml:tr>
				  <xhtml:tr>
				  <xhtml:td>TEMP_SENSOR_LOCK
				  </xhtml:td>
				  <xhtml:td>[31:1] Reserved field; Read only; Default 0<xhtml:br/>[0] Lock bit, locks CRITICAL_TEMP_LIMIT register; Write-1-once; Default 0
				  </xhtml:td>
				  </xhtml:tr>
				  <xhtml:tr>
				  <xhtml:td>TEMP_HW_SHUTDOWN
				  </xhtml:td>
				  <xhtml:td>[31:2] Reserved field; Read only; Default 0<xhtml:br/>[1] Enable hardware shutdown on a critical temperature detection; Read-write; Default 0
				  </xhtml:td>
				  </xhtml:tr>
				  <xhtml:tr>
				  <xhtml:td>CURRENT_TEMP
				  </xhtml:td>
				  <xhtml:td>[31:8] Reserved field; Read only; Default 0<xhtml:br/>[7:0]   Current Temp 0-255 Centigrade; Read-only; Default 0 
				  </xhtml:td>
				  </xhtml:tr>
				  </xhtml:table>
               </Example_Code>				  
			   <Body_Text>
			   <xhtml:p>In this example note that only the CRITICAL_TEMP_LIMIT register is protected by the TEMP_SENSOR_LOCK bit, while the security design intent is to protect any modification of the critical temperature detection and response. 
			   </xhtml:p>
			   <xhtml:p>The response of the system, if the system heats to a critical temperature, is controlled by TEMP_HW_SHUTDOWN bit [1], which is not lockable. Also, the TEMP_SENSOR_CALIB register is not protected by the lock bit.
			   </xhtml:p>
			   <xhtml:p>By modifying the temperature sensor calibration, the conversion of the sensor data to a degree centigrade can be changed, such that the current temperature will never be detected to exceed critical temperature value programmed by the protected lock.
			   </xhtml:p>
			   <xhtml:p>Similarly, by modifying the TEMP_HW_SHUTDOWN.Enable bit, the system response detection of the current temperature exceeding critical temperature can be disabled.
			   </xhtml:p>
			   </Body_Text>
			   <Example_Code Nature="Good"><xhtml:p>Change TEMP_HW_SHUTDOWN and TEMP_SENSOR_CALIB controls to be locked by TEMP_SENSOR_LOCK.
			   </xhtml:p>
			   <xhtml:table>
				<xhtml:tr>
				  <xhtml:td>TEMP_SENSOR_CALIB
				  </xhtml:td>
				  <xhtml:td>[31:0] Thermal sensor calibration data. A slope value used to map sensor reading to a degree Centigrade. Read-write-Lock; Default 25; Locked by TEMP_SENSOR_LOCK bit[0]
				  </xhtml:td>
				  </xhtml:tr>
				  <xhtml:tr>
				  <xhtml:td>TEMP_HW_SHUTDOWN
				  </xhtml:td>
				  <xhtml:td>[31:2] Reserved field; Read only; Default 0<xhtml:p/>[1] Enable hardware shutdown on critical temperature detection; Read-write-Lock; Default 0; Locked by TEMP_SENSOR_LOCK bit[0]
				  </xhtml:td>
				  </xhtml:tr>
				  </xhtml:table>
               </Example_Code>
            </Demonstrative_Example>
         </Demonstrative_Examples>
	    <Observed_Examples>
	      <Observed_Example>
		<Reference>CVE-2018-9085</Reference>
		<Description>Certain servers leave a write protection lock bit
		unset after boot, potentially allowing modification of
		parts of flash memory.</Description>
		<Link>https://www.cve.org/CVERecord?id=CVE-2018-9085</Link>
	      </Observed_Example>
		<Observed_Example>
		  <Reference>CVE-2014-8273</Reference>
		  <Description>Chain: chipset has a race condition (CWE-362) between when an interrupt handler detects an attempt to write-enable the BIOS (in violation of the lock bit), and when the handler resets the write-enable bit back to 0, allowing attackers to issue BIOS writes during the timing window [REF-1237].</Description>
		  <Link>https://www.cve.org/CVERecord?id=CVE-2014-8273</Link>
		</Observed_Example>
	      </Observed_Examples>
         <Related_Attack_Patterns>
            <Related_Attack_Pattern CAPEC_ID="176"/>
            <Related_Attack_Pattern CAPEC_ID="680"/>
         </Related_Attack_Patterns>
         <References>
		<Reference External_Reference_ID="REF-1237"/>
	      </References>
         <Mapping_Notes>
            <Usage>Allowed</Usage>
            <Rationale>This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.</Rationale>
            <Comments>Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.</Comments>
            <Reasons>
               <Reason Type="Acceptable-Use"/>
            </Reasons>
         </Mapping_Notes>
         <Content_History>
            <Submission>
                <Submission_Name>Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi</Submission_Name>
                <Submission_Organization>Intel Corporation</Submission_Organization>
                <Submission_Date>2020-01-15</Submission_Date>
                <Submission_Version>4.0</Submission_Version>
                <Submission_ReleaseDate>2020-02-24</Submission_ReleaseDate>
            </Submission>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-08-20</Modification_Date>
					<Modification_Comment>updated Related_Attack_Patterns</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-03-15</Modification_Date>
					<Modification_Comment>updated Maintenance_Notes</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-10-28</Modification_Date>
					<Modification_Comment>updated Demonstrative_Examples, Description, Detection_Factors, Maintenance_Notes, Name, Observed_Examples, Potential_Mitigations, References, Relationships, Weakness_Ordinalities</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2022-04-28</Modification_Date>
					<Modification_Comment>updated Related_Attack_Patterns, Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-04-27</Modification_Date>
					<Modification_Comment>updated Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-06-29</Modification_Date>
					<Modification_Comment>updated Mapping_Notes</Modification_Comment>
				</Modification>
				<Contribution Type="Feedback">
				  <Contribution_Name>Narasimha Kumar V Mangipudi</Contribution_Name>
				  <Contribution_Organization>Lattice Semiconductor</Contribution_Organization>
				  <Contribution_Date>2021-10-20</Contribution_Date>
				  <Contribution_Comment>reviewed content changes</Contribution_Comment>
				</Contribution>
			<Previous_Entry_Name Date="2021-10-28">Improper Hardware Lock Protection for Security Sensitive Controls</Previous_Entry_Name>
         </Content_History>
      </Weakness>
      <Weakness ID="1240" Name="Use of a Cryptographic Primitive with a Risky Implementation" Abstraction="Base" Structure="Simple" Status="Draft">
            <Description>To fulfill the need for a cryptographic primitive, the product implements a cryptographic algorithm using a non-standard, unproven, or disallowed/non-compliant cryptographic implementation.</Description>
            <Extended_Description>
	      <xhtml:p>Cryptographic protocols and systems depend on cryptographic primitives (and associated algorithms) as their basic building blocks. Some common examples of primitives are digital signatures, one-way hash functions, ciphers, and public key cryptography; however, the notion of "primitive" can vary depending on point of view. See "Terminology Notes" for further explanation of some concepts.</xhtml:p>
	      <xhtml:p>Cryptographic primitives are defined to accomplish one very specific task in a precisely defined and mathematically reliable fashion. For example, suppose that for a specific cryptographic primitive (such as an encryption routine), the consensus is that the primitive can only be broken after trying out N different inputs (where the larger the value of N, the stronger the cryptography). For an encryption scheme like AES-256, one would expect N to be so large as to be infeasible to execute in a reasonable amount of time.</xhtml:p>
	      <xhtml:p>If a vulnerability is ever found that shows that one can break a cryptographic primitive in significantly less than the expected number of attempts, then that primitive is considered weakened (or sometimes in extreme cases, colloquially it is "broken"). As a result, anything using this cryptographic primitive would now be considered insecure or risky. Thus, even breaking or weakening a seemingly small cryptographic primitive has the potential to render the whole system vulnerable, due to its reliance on the primitive. A historical example can be found in TLS when using DES. One would colloquially call DES the cryptographic primitive for transport encryption in this version of TLS. In the past, DES was considered strong, because no weaknesses were found in it; importantly, DES has a key length of 56 bits. Trying N=2^56 keys was considered impractical for most actors. Unfortunately, attacking a system with 56-bit keys is now practical via brute force, which makes defeating DES encryption practical. It is now practical for an adversary to read any information sent under this version of TLS and use this information to attack the system. As a result, it can be claimed that this use of TLS is weak, and that any system depending on TLS with DES could potentially render the entire system vulnerable to attack.</xhtml:p>

	      <xhtml:p>Cryptographic primitives and associated algorithms are only considered safe after extensive research and review from experienced cryptographers from academia, industry, and government entities looking for any possible flaws. Furthermore, cryptographic primitives and associated algorithms are frequently reevaluated for safety when new mathematical and attack techniques are discovered.  As a result and over time, even well-known cryptographic primitives can lose their compliance status with the discovery of novel attacks that might either defeat the algorithm or reduce its robustness significantly.</xhtml:p>
	      <xhtml:p>If ad-hoc cryptographic primitives are implemented, it is almost certain that the implementation will be vulnerable to attacks that are well understood by cryptographers, resulting in the exposure of sensitive information and other consequences.</xhtml:p>
	      <xhtml:p>This weakness is even more difficult to manage for hardware-implemented deployment of cryptographic algorithms. First, because hardware is not patchable as easily as software, any flaw discovered after release and production typically cannot be fixed without a recall of the product. Secondly, the hardware product is often expected to work for years, during which time computation power available to the attacker only increases. Therefore, for hardware implementations of cryptographic primitives, it is absolutely essential that only strong, proven cryptographic primitives are used.</xhtml:p>
	    </Extended_Description>
            <Related_Weaknesses>
              <Related_Weakness Nature="ChildOf" CWE_ID="327" View_ID="1000" Ordinal="Primary"/>
            </Related_Weaknesses>
		 <Weakness_Ordinalities>
            <Weakness_Ordinality>
               <Ordinality>Primary</Ordinality>
            </Weakness_Ordinality>
		 </Weakness_Ordinalities>
            <Applicable_Platforms>
                <Language Class="Not Language-Specific" Prevalence="Undetermined"/>
                <Operating_System Class="Not OS-Specific" Prevalence="Undetermined"/>
                <Architecture Class="Not Architecture-Specific" Prevalence="Undetermined"/>
                <Technology Class="System on Chip" Prevalence="Undetermined"/>
            </Applicable_Platforms>
			<Modes_Of_Introduction>
				<Introduction>
					<Phase>Architecture and Design</Phase>
					<Note>This weakness is primarily introduced during the architecture and design phase as risky primitives are included.</Note>
				</Introduction>
				<Introduction>
					<Phase>Implementation</Phase>
					<Note>Even in cases where the Architectural phase properly specifies a cryptographically secure design, the design may be changed during implementation due to unforeseen constraints.</Note>
				</Introduction>
			</Modes_Of_Introduction>
			<Common_Consequences>
				<Consequence>
					<Scope>Confidentiality</Scope>
					<Impact>Read Application Data</Impact>
					<Likelihood>High</Likelihood>
					<Note>Incorrect usage of crypto primitives could render the supposedly encrypted data as unencrypted plaintext in the worst case.</Note>
				</Consequence>
			</Common_Consequences>
	    <Detection_Methods>
	      <Detection_Method>
		<Method>Architecture or Design Review</Method>
		<Description>Review requirements, documentation, and product design to ensure that primitives are consistent with the strongest-available recommendations from trusted parties. If the product appears to be using custom or proprietary implementations that have not had sufficient public review and approval, then this is a significant concern.</Description>
		<Effectiveness>High</Effectiveness>
	      </Detection_Method>
	      <Detection_Method>
		<Method>Manual Analysis</Method>
		<Description>Analyze the product to ensure that implementations for each primitive do not contain any known vulnerabilities and are not using any known-weak algorithms, including MD4, MD5, SHA1, DES, etc.</Description>
		<Effectiveness>Moderate</Effectiveness>
	      </Detection_Method>
	      <Detection_Method>
		<Method>Dynamic Analysis with Manual Results Interpretation</Method>
		<Description>For hardware, during the implementation (pre-Silicon / post-Silicon) phase, dynamic tests should be done to ensure that outputs from cryptographic routines are indeed working properly, such as test vectors provided by NIST [REF-1236].</Description>
		<Effectiveness>Moderate</Effectiveness>
	      </Detection_Method>
	      <Detection_Method>
		<Method>Dynamic Analysis with Manual Results Interpretation</Method>
		<Description>
		It needs to be determined if the output of a cryptographic primitive is lacking entropy, which is one clear sign that something went wrong with the crypto implementation. There exist many methods of measuring the entropy of a bytestream, from sophisticated ones (like calculating Shannon's entropy of a sequence of characters) to crude ones (by compressing it and comparing the size of the original bytestream vs. the compressed - a truly random byte stream should not be compressible and hence the uncompressed and compressed bytestreams should be nearly identical in size).</Description>
		<Effectiveness>Moderate</Effectiveness>
	      </Detection_Method>
	    </Detection_Methods>
	    <Potential_Mitigations>
		<Mitigation Mitigation_ID="MIT-55">
		  <Phase>Requirements</Phase>
		  <Description>
		      Require compliance with the strongest-available recommendations from trusted parties, and require that compliance must be kept up-to-date, since recommendations evolve over time. For example, US government systems require FIPS 140-3 certification, which supersedes FIPS 140-2 [REF-1192] [REF-1226].
		  </Description>
		  <Effectiveness>High</Effectiveness>
		</Mitigation>
		<Mitigation>
		  <Phase>Architecture and Design</Phase>
		  <Description>
		      Ensure that the architecture/design uses the strongest-available primitives and algorithms from trusted parties. For example, US government systems require FIPS 140-3 certification, which supersedes FIPS 140-2 [REF-1192] [REF-1226].
		  </Description>
		  <Effectiveness>High</Effectiveness>
		</Mitigation>
		<Mitigation Mitigation_ID="MIT-54">
		  <Phase>Architecture and Design</Phase>
		  <Description>
		      Do not develop custom or private cryptographic algorithms. They will likely be exposed to attacks that are well-understood by cryptographers. As with all cryptographic mechanisms, the source code should be available for analysis. If the algorithm may be compromised when attackers find out how it works, then it is especially weak.
		  </Description>
		  <Effectiveness>Discouraged Common Practice</Effectiveness>
		</Mitigation>
		<Mitigation>
		  <Phase>Architecture and Design</Phase>
		  <Description>
		      Try not to use cryptographic algorithms in novel ways or with new modes of operation even when you "know" it is secure. For example, using SHA-2 chaining to create a 1-time pad for encryption might sound like a good idea, but one should not do this.
		  </Description>
		  <Effectiveness>Discouraged Common Practice</Effectiveness>
		</Mitigation>
        <Mitigation Mitigation_ID="MIT-52">
          <Phase>Architecture and Design</Phase>
          <Description>Ensure that the design can replace one cryptographic primitive or algorithm with another in the next generation ("cryptographic agility"). Where possible, use wrappers to make the interfaces uniform. This will make it easier to upgrade to stronger algorithms. This is especially important for hardware, which can be more difficult to upgrade quickly than software; design the hardware at a replaceable block level.</Description>
		  <Effectiveness>Defense in Depth</Effectiveness>
        </Mitigation>
		<Mitigation>
		  <Phase>Architecture and Design</Phase>
		  <Description>
		      Do not use outdated or non-compliant cryptography algorithms. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong [REF-267].
		  </Description>
		  <Effectiveness>Discouraged Common Practice</Effectiveness>
		</Mitigation>
		<Mitigation>
		  <Phase>Architecture and Design</Phase>
		  <Phase>Implementation</Phase>
		  <Description>
		      Do not use a linear-feedback shift register (LFSR) or other legacy methods as a substitute for an accepted and standard Random Number Generator.
		  </Description>
		  <Effectiveness>Discouraged Common Practice</Effectiveness>
		</Mitigation>
		<Mitigation>
		  <Phase>Architecture and Design</Phase>
		  <Phase>Implementation</Phase>
		  <Description>
		      Do not use a checksum as a substitute for a cryptographically generated hash.
		  </Description>
		  <Effectiveness>Discouraged Common Practice</Effectiveness>
		</Mitigation>
		<Mitigation>
		  <Phase>Architecture and Design</Phase>
		  <Strategy>Libraries or Frameworks</Strategy>
		  <Description>
		      Use a vetted cryptographic library or framework. Industry-standard implementations will save development time and are more likely to avoid errors that can occur during implementation of cryptographic algorithms. However, the library/framework could be used incorrectly during implementation.
		  </Description>
		  <Effectiveness>High</Effectiveness>
		</Mitigation>
		<Mitigation>
		  <Phase>Architecture and Design</Phase>
		  <Phase>Implementation</Phase>
		  <Description>
		      When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for the prevention of common attacks.
		  </Description>
		  <Effectiveness>Moderate</Effectiveness>
		</Mitigation>
		<Mitigation>
		  <Phase>Architecture and Design</Phase>
		  <Phase>Implementation</Phase>
		  <Description>
		      Do not store keys in areas accessible to untrusted agents. Carefully manage and protect the cryptographic keys (see CWE-320). If the keys can be guessed or stolen, then the strength of the cryptography algorithm is irrelevant.
		  </Description>
		  <Effectiveness>Moderate</Effectiveness>
		</Mitigation>
	      </Potential_Mitigations>
			<Demonstrative_Examples>
				<Demonstrative_Example>
					<Intro_Text>Re-using random values may compromise security.</Intro_Text>
					<Example_Code Nature="Bad">Suppose an Encryption algorithm needs a random value for a key. Instead of using a DRNG (Deterministic Random Number Generator), the designer uses a linear-feedback shift register (LFSR) to generate the value.</Example_Code>
					<Body_Text>While an LFSR may provide pseudo-random number generation service, the entropy (measure of randomness) of the resulting output may be less than that of an accepted DRNG (like that used in dev/urandom). Thus, using an LFSR weakens the strength of the cryptographic system, because it may be possible for an attacker to guess the LFSR output and subsequently the encryption key.</Body_Text>
					<Example_Code Nature="Good">If a cryptographic algorithm expects a random number as its input, provide one. Do not provide a pseudo-random value.</Example_Code>
				</Demonstrative_Example>
			</Demonstrative_Examples>
      <Observed_Examples>
      	<Observed_Example>
          <Reference>CVE-2020-4778</Reference>
          <Description>software uses MD5, which is less safe than the default SHA-256 used by related products</Description>
          <Link>https://www.cve.org/CVERecord?id=CVE-2020-4778</Link>
      	</Observed_Example>
            <Observed_Example>
               <Reference>CVE-2005-2946</Reference>
               <Description>Default configuration of product uses MD5 instead of stronger algorithms that are available, simplifying forgery of certificates.</Description>
               <Link>https://www.cve.org/CVERecord?id=CVE-2005-2946</Link>
            </Observed_Example>
		<Observed_Example>
		  <Reference>CVE-2019-3907</Reference>
		  <Description>identity card uses MD5 hash of a salt and password</Description>
		  <Link>https://www.cve.org/CVERecord?id=CVE-2019-3907</Link>
		</Observed_Example>
		<Observed_Example>
		  <Reference>CVE-2021-34687</Reference>
		  <Description>personal key is transmitted over the network using a substitution cipher</Description>
		  <Link>https://www.cve.org/CVERecord?id=CVE-2021-34687</Link>
		</Observed_Example>
		<Observed_Example>
		  <Reference>CVE-2020-14254</Reference>
		  <Description>product does not disable TLS-RSA cipher suites, allowing decryption of traffic if TLS 2.0 and secure ciphers are not enabled.</Description>
		  <Link>https://www.cve.org/CVERecord?id=CVE-2020-14254</Link>
		</Observed_Example>
		<Observed_Example>
		  <Reference>CVE-2019-1543</Reference>
		  <Description>SSL/TLS library generates 16-byte nonces but reduces them to 12 byte nonces for the ChaCha20-Poly1305 cipher, converting them in a way that violates the cipher's requirements for unique nonces.</Description>
		  <Link>https://www.cve.org/CVERecord?id=CVE-2019-1543</Link>
		</Observed_Example>
		<Observed_Example>
		  <Reference>CVE-2017-9267</Reference>
		  <Description>LDAP interface allows use of weak ciphers</Description>
		  <Link>https://www.cve.org/CVERecord?id=CVE-2017-9267</Link>
		</Observed_Example>
		<Observed_Example>
		  <Reference>CVE-2017-7971</Reference>
		  <Description>SCADA product allows "use of outdated cipher suites"</Description>
		  <Link>https://www.cve.org/CVERecord?id=CVE-2017-7971</Link>
		</Observed_Example>
		<Observed_Example>
		  <Reference>CVE-2020-6616</Reference>
		  <Description>Chip implementing Bluetooth uses a low-entropy PRNG instead of a hardware RNG, allowing spoofing.</Description>
		  <Link>https://www.cve.org/CVERecord?id=CVE-2020-6616</Link>
		</Observed_Example>
		<Observed_Example>
		  <Reference>CVE-2019-1715</Reference>
		  <Description>security product has insufficient entropy in the DRBG, allowing collisions and private key discovery</Description>
		  <Link>https://www.cve.org/CVERecord?id=CVE-2019-1715</Link>
		</Observed_Example>
		<Observed_Example>
		  <Reference>CVE-2014-4192</Reference>
		  <Description>Dual_EC_DRBG implementation in RSA toolkit does not correctly handle certain byte requests, simplifying plaintext recovery</Description>
		  <Link>https://www.cve.org/CVERecord?id=CVE-2014-4192</Link>
		</Observed_Example>
		<Observed_Example>
		  <Reference>CVE-2007-6755</Reference>
		  <Description>Recommendation for Dual_EC_DRBG algorithm contains point Q constants that could simplify decryption</Description>
		  <Link>https://www.cve.org/CVERecord?id=CVE-2007-6755</Link>
		</Observed_Example>
      </Observed_Examples>
         <Related_Attack_Patterns>
            <Related_Attack_Pattern CAPEC_ID="97"/>
         </Related_Attack_Patterns>
         <References>
	   <Reference External_Reference_ID="REF-267"/>
	   <Reference External_Reference_ID="REF-1227"/>
	   <Reference External_Reference_ID="REF-1226"/>
	   <Reference External_Reference_ID="REF-1192"/>
	   <Reference External_Reference_ID="REF-1236" Section="Test Vectors"/>
         </References>
         <Mapping_Notes>
            <Usage>Allowed</Usage>
            <Rationale>This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.</Rationale>
            <Comments>Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.</Comments>
            <Reasons>
               <Reason Type="Acceptable-Use"/>
            </Reasons>
         </Mapping_Notes>
         <Notes>
	   <Note Type="Terminology">
	     <xhtml:p>
	     Terminology for cryptography varies widely, from informal and colloquial to mathematically-defined, with different precision and formalism depending on whether the stakeholder is a developer, cryptologist, etc. Yet there is a need for CWE to be self-consistent while remaining understandable and acceptable to multiple audiences.</xhtml:p>
	     <xhtml:p>As of CWE 4.6, CWE terminology around "primitives" and "algorithms" is emerging as shown by the following example, subject to future consultation and agreement within the CWE and cryptography communities. Suppose one wishes to send encrypted data using a CLI tool such as OpenSSL. One might choose to use AES with a 256-bit key and require tamper protection (GCM mode, for instance). For compatibility's sake, one might also choose the ciphertext to be formatted to the PKCS#5 standard. In this case, the "cryptographic system" would be AES-256-GCM with PKCS#5 formatting. The "cryptographic function" would be AES-256 in the GCM mode of operation, and the "algorithm" would be AES. Colloquially, one would say that AES (and sometimes AES-256) is the "cryptographic primitive," because it is the algorithm that realizes the concept of symmetric encryption (without modes of operation or other protocol related modifications). In practice, developers and architects typically refer to base cryptographic algorithms (AES, SHA, etc.) as cryptographic primitives.</xhtml:p>
	   </Note>
           <Note Type="Maintenance">Since CWE 4.4, various cryptography-related entries, including CWE-327 and CWE-1240, have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing.</Note>
         </Notes>
			<Content_History>
                <Submission>
                    <Submission_Name>Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi</Submission_Name>
                    <Submission_Organization>Intel Corporation</Submission_Organization>
					<Submission_Date>2020-02-10</Submission_Date>
					<Submission_Version>4.0</Submission_Version>
					<Submission_ReleaseDate>2020-02-24</Submission_ReleaseDate>
                </Submission>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-08-20</Modification_Date>
					<Modification_Comment>updated Background_Details, Common_Consequences, Demonstrative_Examples, Description, Maintenance_Notes, Modes_of_Introduction, Potential_Mitigations, Related_Attack_Patterns, Research_Gaps</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-07-20</Modification_Date>
					<Modification_Comment>updated Maintenance_Notes, Research_Gaps</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-10-28</Modification_Date>
					<Modification_Comment>updated Background_Details, Demonstrative_Examples, Description, Detection_Factors, Maintenance_Notes, Name, Observed_Examples, Potential_Mitigations, References, Relationships, Terminology_Notes, Weakness_Ordinalities</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-04-27</Modification_Date>
					<Modification_Comment>updated References, Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-06-29</Modification_Date>
					<Modification_Comment>updated Mapping_Notes</Modification_Comment>
				</Modification>
				<Contribution Type="Content">
				  <Contribution_Name>Parbati K. Manna</Contribution_Name>
				  <Contribution_Organization>Intel Corporation</Contribution_Organization>
				  <Contribution_Date>2021-10-18</Contribution_Date>
				  <Contribution_Comment>provided detection methods and observed examples</Contribution_Comment>
				</Contribution>
			<Previous_Entry_Name Date="2021-10-28">Use of a Risky Cryptographic Primitive</Previous_Entry_Name>
            </Content_History>
        </Weakness>
      <Weakness ID="1244" Name="Internal Asset Exposed to Unsafe Debug Access Level or State" Abstraction="Base" Structure="Simple" Status="Stable">

        <Description>The product uses physical debug or test
        interfaces with support for multiple access levels, but it
        assigns the wrong debug access level to an internal asset,
        providing unintended access to the asset from untrusted debug
        agents.</Description>

        <Extended_Description>
	  <xhtml:p>Debug authorization can have multiple levels of
	  access, defined such that different system internal assets
	  are accessible based on the current authorized debug
	  level. Other than debugger authentication (e.g., using
	  passwords or challenges), the authorization can also be
	  based on the system state or boot stage. For example, full
	  system debug access might only be allowed early in boot
	  after a system reset to ensure that previous session data is
	  not accessible to the authenticated debugger.</xhtml:p>

          <xhtml:p>If this protection mechanism does not ensure that
          internal assets have the correct debug access level during
          each boot stage or change in system state, an attacker could
          obtain sensitive information from the internal asset using a
          debugger.</xhtml:p>
        </Extended_Description>
	<Related_Weaknesses>
	  <Related_Weakness Nature="ChildOf" CWE_ID="863" View_ID="1000" Ordinal="Primary"/>
	</Related_Weaknesses>
		 <Weakness_Ordinalities>
            <Weakness_Ordinality>
               <Ordinality>Primary</Ordinality>
            </Weakness_Ordinality>
		 </Weakness_Ordinalities>
            <Applicable_Platforms>
                <Language Class="Not Language-Specific" Prevalence="Undetermined"/>
                <Operating_System Class="Not OS-Specific" Prevalence="Undetermined"/>
                <Architecture Class="Not Architecture-Specific" Prevalence="Undetermined"/>
                <Technology Class="System on Chip" Prevalence="Undetermined"/>
            </Applicable_Platforms>
            <Modes_Of_Introduction>
                <Introduction>
                    <Phase>Architecture and Design</Phase>
                </Introduction>
                <Introduction>
                    <Phase>Implementation</Phase>
                </Introduction>
            </Modes_Of_Introduction>
            <Common_Consequences>
                <Consequence>
                    <Scope>Confidentiality</Scope>
                    <Impact>Read Memory</Impact>
                </Consequence>
                <Consequence>
                    <Scope>Integrity</Scope>
                    <Impact>Modify Memory</Impact>
                </Consequence>
                <Consequence>
                    <Scope>Authorization</Scope>
                    <Scope>Access Control</Scope>
                    <Impact>Gain Privileges or Assume Identity</Impact>
                    <Impact>Bypass Protection Mechanism</Impact>
                </Consequence>
            </Common_Consequences>
	    <Detection_Methods>
	      <Detection_Method>
		<Method>Manual Analysis</Method>
		<Description>Check 2 devices for their passcode to authenticate access to JTAG/debugging ports. If the passcodes are missing or the same, update the design to fix and retest. Check communications over JTAG/debugging ports for encryption. If the communications are not encrypted, fix the design and retest.</Description>
		<Effectiveness>Moderate</Effectiveness>
	      </Detection_Method>
	    </Detection_Methods>
            <Potential_Mitigations>
                <Mitigation>
                  <Phase>Architecture and Design</Phase>
                  <Phase>Implementation</Phase>
                  <Description>
                    <xhtml:p>For security-sensitive assets accessible over debug/test interfaces, only allow trusted agents.</xhtml:p>
                  </Description>
		  <Effectiveness>High</Effectiveness>
		</Mitigation>
		<Mitigation>
		  <Phase>Architecture and Design</Phase>
		  <Description>Apply blinding [REF-1219] or masking techniques in strategic areas.</Description>
		  <Effectiveness>Limited</Effectiveness>
		</Mitigation>
		<Mitigation>
		  <Phase>Implementation</Phase>
		  <Description>Add shielding or tamper-resistant protections to the device, which increases the difficulty and cost for accessing debug/test interfaces.</Description>
		  <Effectiveness>Limited</Effectiveness>
                </Mitigation>
            </Potential_Mitigations>
            <Demonstrative_Examples>
                <Demonstrative_Example>
                    <Intro_Text>The JTAG interface is used to perform debugging and provide CPU core access for developers. JTAG-access protection is implemented as part of the JTAG_SHIELD bit in the hw_digctl_ctrl register. This register has no default value at power up and is set only after the system boots from ROM and control is transferred to the user software.</Intro_Text>
                    <Example_Code Nature="Bad" Language="Other">
                        <xhtml:table>
                            <xhtml:tbody>
                                <xhtml:tr>
                                    <xhtml:td>1 bit</xhtml:td>
                                    <xhtml:td>0x0 = JTAG debugger is enabled (default)</xhtml:td>
                                </xhtml:tr>
                                <xhtml:tr>
                                    <xhtml:td>JTAG_SHIELD</xhtml:td>
                                    <xhtml:td>0x1 = JTAG debugger is disabled</xhtml:td>
                                </xhtml:tr>
                            </xhtml:tbody>
                        </xhtml:table>
                    </Example_Code>
                    <Body_Text>This means that since the end user has access to JTAG at system reset and during ROM code execution before control is transferred to user software, a JTAG user can modify the boot flow and subsequently disclose all CPU information, including data-encryption keys.</Body_Text>
                	<Example_Code Nature="Informative">
                  		<xhtml:div>The default value of this register bit should be set to 1 to prevent the JTAG from being enabled at system reset.</xhtml:div>
               		</Example_Code> 
            	</Demonstrative_Example>
                <Demonstrative_Example>
                    <Intro_Text>The example code below is taken from the CVA6 processor core of the HACK@DAC'21 buggy OpenPiton SoC. Debug access allows users to access internal hardware registers that are otherwise not exposed for user access or restricted access through access control protocols. Hence, requests to enter debug mode are checked and authorized only if the processor has sufficient privileges. In addition, debug accesses are also locked behind password checkers. Thus, the processor enters debug mode only when the privilege level requirement is met, and the correct debug password is provided.</Intro_Text>
                    <Body_Text>The following code [REF-1377] illustrates an instance of a vulnerable implementation of debug mode. The core correctly checks if the debug requests have sufficient privileges and enables the debug_mode_d and debug_mode_q signals. It also correctly checks for debug password and enables umode_i signal.</Body_Text>
                    <Example_Code Nature="Bad" Language="Verilog">
                    module csr_regfile #(<xhtml:br/>
                    ...<xhtml:br/>
                        <xhtml:div style="margin-left:1em;">
                        // check that we actually want to enter debug depending on the privilege level we are currently in<xhtml:br/>
                        unique case (priv_lvl_o)<xhtml:br/>
                            <xhtml:div style="margin-left:1em;">
                            riscv::PRIV_LVL_M: begin<xhtml:br/>
                                <xhtml:div style="margin-left:1em;">
                                debug_mode_d = dcsr_q.ebreakm;<xhtml:br/>
                                </xhtml:div>
                            </xhtml:div>
                        </xhtml:div>
                    ...<xhtml:br/>
                        <xhtml:div style="margin-left:1em;">
                            <xhtml:div style="margin-left:1em;">
                            riscv::PRIV_LVL_U: begin<xhtml:br/>
                                <xhtml:div style="margin-left:1em;">
                                debug_mode_d = dcsr_q.ebreaku;<xhtml:br/>
                                </xhtml:div>
                            </xhtml:div>
                        </xhtml:div>
                    ...<xhtml:br/>
                        <xhtml:div style="margin-left:1em;">
                        <xhtml:b>assign priv_lvl_o = (debug_mode_q || umode_i) ?  riscv::PRIV_LVL_M : priv_lvl_q;</xhtml:b><xhtml:br/>
                        </xhtml:div>
                    ...<xhtml:br/>
                        <xhtml:div style="margin-left:1em;">
                        debug_mode_q  &lt;= debug_mode_d;<xhtml:br/>
                        </xhtml:div>
                    ...<xhtml:br/>
                    </Example_Code>
                    <Body_Text>However, it grants debug access and changes the privilege level, priv_lvl_o, even when one of the two checks is satisfied and the other is not. Because of this, debug access can be granted by simply requesting with sufficient privileges (i.e., debug_mode_q is enabled) and failing the password check (i.e., umode_i is disabled). This allows an attacker to bypass the debug password checking and gain debug access to the core, compromising the security of the processor.</Body_Text>
                    <Body_Text>A fix to this issue is to only change the privilege level of the processor when both checks are satisfied, i.e., the request has enough privileges (i.e., debug_mode_q is enabled) and the password checking is successful (i.e., umode_i is enabled) [REF-1378].</Body_Text>
                    <Example_Code Nature="Good" Language="Verilog">
                    module csr_regfile #(<xhtml:br/>
                    ...<xhtml:br/>
                        <xhtml:div style="margin-left:1em;">
                        // check that we actually want to enter debug depending on the privilege level we are currently in<xhtml:br/>
                        unique case (priv_lvl_o)<xhtml:br/>
                            <xhtml:div style="margin-left:1em;">
                            riscv::PRIV_LVL_M: begin<xhtml:br/>
                                <xhtml:div style="margin-left:1em;">
                                debug_mode_d = dcsr_q.ebreakm;<xhtml:br/>
                                </xhtml:div>
                            </xhtml:div>
                        </xhtml:div>
                    ...<xhtml:br/>
                        <xhtml:div style="margin-left:1em;">
                            <xhtml:div style="margin-left:1em;">
                            riscv::PRIV_LVL_U: begin<xhtml:br/>
                                <xhtml:div style="margin-left:1em;">
                                debug_mode_d = dcsr_q.ebreaku;<xhtml:br/>
                                </xhtml:div>
                            </xhtml:div>
                        </xhtml:div>
                    ...<xhtml:br/>
                        <xhtml:div style="margin-left:1em;">
                        assign priv_lvl_o = <xhtml:b>(debug_mode_q &amp;&amp; umode_i) ? riscv::PRIV_LVL_M : priv_lvl_q;</xhtml:b><xhtml:br/>
                        </xhtml:div>
                    ...<xhtml:br/>
                        <xhtml:div style="margin-left:1em;">
                        debug_mode_q  &lt;= debug_mode_d;<xhtml:br/>
                        </xhtml:div>
                    ...<xhtml:br/>
                    </Example_Code>
                </Demonstrative_Example>
            </Demonstrative_Examples>
            <Observed_Examples>
            	<Observed_Example>
               		<Reference>CVE-2019-18827</Reference>
               		<Description>After ROM code execution, JTAG access is disabled. But before the ROM code is executed, JTAG access is possible, allowing a user full system access.  This allows a user to modify the boot flow and successfully bypass the secure-boot process.</Description>
               		<Link>https://www.cve.org/CVERecord?id=CVE-2019-18827</Link>
           		 </Observed_Example>
           	</Observed_Examples>
         <Related_Attack_Patterns>
            <Related_Attack_Pattern CAPEC_ID="114"/>
         </Related_Attack_Patterns>
         <References>
                <Reference External_Reference_ID="REF-1056"/>
                <Reference External_Reference_ID="REF-1057"/>
                <Reference External_Reference_ID="REF-1219"/>
                <Reference External_Reference_ID="REF-1377"/>
                <Reference External_Reference_ID="REF-1378"/>
            </References>
         <Mapping_Notes>
            <Usage>Allowed</Usage>
            <Rationale>This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.</Rationale>
            <Comments>Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.</Comments>
            <Reasons>
               <Reason Type="Acceptable-Use"/>
            </Reasons>
         </Mapping_Notes>
      <Notes>
	<Note Type="Relationship">
	  CWE-1191 and CWE-1244 both involve physical debug access,
	  but the weaknesses are different. CWE-1191 is effectively
	  about missing authorization for a debug interface,
	  i.e. JTAG.  CWE-1244 is about providing internal assets with
	  the wrong debug access level, exposing the asset to
	  untrusted debug agents.</Note>
      </Notes>
            <Content_History>
                <Submission>
                    <Submission_Name>Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi</Submission_Name>
                    <Submission_Organization>Intel Corporation</Submission_Organization>
                    <Submission_Date>2020-02-12</Submission_Date>
                    <Submission_Version>4.0</Submission_Version>
                    <Submission_ReleaseDate>2020-02-24</Submission_ReleaseDate>
                </Submission>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-08-20</Modification_Date>
					<Modification_Comment>updated Demonstrative_Examples, Name, Observed_Examples, Related_Attack_Patterns</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-03-15</Modification_Date>
					<Modification_Comment>updated Maintenance_Notes</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-10-28</Modification_Date>
					<Modification_Comment>updated Demonstrative_Examples, Description, Detection_Factors, Maintenance_Notes, Name, Observed_Examples, Potential_Mitigations, References, Relationship_Notes, Relationships, Weakness_Ordinalities</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2022-04-28</Modification_Date>
					<Modification_Comment>updated Related_Attack_Patterns</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-04-27</Modification_Date>
					<Modification_Comment>updated References, Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-06-29</Modification_Date>
					<Modification_Comment>updated Mapping_Notes</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2024-02-29</Modification_Date>
					<Modification_Version>4.14</Modification_Version>
					<Modification_ReleaseDate>2024-02-29</Modification_ReleaseDate>
					<Modification_Comment>updated Demonstrative_Examples, References</Modification_Comment>
				</Modification>
	    <Contribution Type="Content">
	      <Contribution_Name>Hareesh Khattri</Contribution_Name>
	      <Contribution_Organization>Intel Corporation</Contribution_Organization>
	      <Contribution_Date>2021-10-22</Contribution_Date>
	      <Contribution_Comment>clarified differences between CWE-1191 and CWE-1244, and suggested rephrasing of descriptions and names.</Contribution_Comment>
	    </Contribution>
                <Contribution Type="Content">
					<Contribution_Name>Chen Chen, Rahul Kande, Jeyavijayan Rajendran</Contribution_Name>
					<Contribution_Organization>Texas A&amp;M University</Contribution_Organization>
					<Contribution_Date>2023-11-07</Contribution_Date>
					<Contribution_Comment>suggested demonstrative example</Contribution_Comment>
				</Contribution>
				<Contribution Type="Content">
					<Contribution_Name>Shaza Zeitouni, Mohamadreza Rostami, Ahmad-Reza Sadeghi</Contribution_Name>
					<Contribution_Organization>Technical University of Darmstadt</Contribution_Organization>
					<Contribution_Date>2023-11-07</Contribution_Date>
					<Contribution_Comment>suggested demonstrative example</Contribution_Comment>
				</Contribution>
			<Previous_Entry_Name Date="2020-08-20">Improper Authorization on Physical Debug and Test Interfaces</Previous_Entry_Name>
			<Previous_Entry_Name Date="2021-10-28">Improper Access to Sensitive Information Using Debug and Test Interfaces</Previous_Entry_Name>
            </Content_History>
        </Weakness>
      <Weakness ID="1256" Name="Improper Restriction of Software Interfaces to Hardware Features" Abstraction="Base" Structure="Simple" Status="Stable">

			<Description>The product provides software-controllable
			device functionality for capabilities such as power and
			clock management, but it does not properly limit
			functionality that can lead to modification of
			hardware memory or register bits, or the ability to
			observe physical side channels.</Description>
            <Extended_Description>
              <xhtml:p>It is frequently assumed that physical attacks
              such as fault injection and side-channel analysis
              require an attacker to have physical access to the
              target device.  This assumption may be false if the
              device has improperly secured power management features,
              or similar features.  For mobile devices, minimizing
              power consumption is critical, but these devices run a
              wide variety of applications with different performance
              requirements. Software-controllable mechanisms to
              dynamically scale device voltage and frequency and
              monitor power consumption are common features in today's
              chipsets, but they also enable attackers to mount fault
              injection and side-channel attacks without having
              physical access to the device.</xhtml:p>
			  
              <xhtml:p>Fault injection attacks involve strategic
              manipulation of bits in a device to achieve a desired
              effect such as skipping an authentication step,
              elevating privileges, or altering the output of a
              cryptographic operation.  Manipulation of the device
              clock and voltage supply is a well-known technique to
              inject faults and is cheap to implement with physical
              device access.  Poorly protected power management
              features allow these attacks to be performed from
              software.  Other features, such as the ability to write
              repeatedly to DRAM at a rapid rate from unprivileged
              software, can result in bit flips in other memory
              locations (Rowhammer, [REF-1083]).</xhtml:p>

			  <xhtml:p>Side channel analysis requires gathering
			  measurement traces of physical quantities such as power
			  consumption.  Modern processors often include power
			  metering capabilities in the hardware itself (e.g.,
			  Intel RAPL) which if not adequately protected enable
			  attackers to gather measurements necessary for
			  performing side-channel attacks from software.</xhtml:p>
            </Extended_Description>
			<Related_Weaknesses>
			  <Related_Weakness Nature="ChildOf" CWE_ID="285" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
		 <Weakness_Ordinalities>
            <Weakness_Ordinality>
               <Ordinality>Primary</Ordinality>
            </Weakness_Ordinality>
		 </Weakness_Ordinalities>
            <Applicable_Platforms>
                <Language Class="Not Language-Specific" Prevalence="Undetermined"/>
                <Operating_System Class="Not OS-Specific" Prevalence="Undetermined"/>
                <Architecture Class="Not Architecture-Specific" Prevalence="Undetermined"/>
                <Technology Class="Not Technology-Specific" Prevalence="Undetermined"/>
				<Technology Name="Memory Hardware" Prevalence="Undetermined"/>
			    <Technology Name="Power Management Hardware" Prevalence="Undetermined"/>
				<Technology Name="Clock/Counter Hardware" Prevalence="Undetermined"/>
            </Applicable_Platforms>
            <Modes_Of_Introduction>
                <Introduction>
                    <Phase>Architecture and Design</Phase>
					<Note>An architect may initiate introduction of
					this weakness via exacting requirements for
					software accessible power/clock management
					requirements</Note>
                </Introduction>
                <Introduction>
		            <Phase>Implementation</Phase>
					<Note>An implementer may introduce this weakness
					by assuming there are no consequences to unbounded
					power and clock management for secure components
					from untrusted ones.</Note>
                </Introduction>
            </Modes_Of_Introduction>
            <Common_Consequences>
                <Consequence>
                    <Scope>Integrity</Scope>
                    <Impact>Modify Memory</Impact>
                    <Impact>Modify Application Data</Impact>
                    <Impact>Bypass Protection Mechanism</Impact>
                </Consequence>
            </Common_Consequences>
	    <Detection_Methods>
	      <Detection_Method>
		<Method>Manual Analysis</Method>
		<Description>Perform a security evaluation of system-level
		architecture and design with software-aided physical attacks
		in scope.</Description>
	      </Detection_Method>
	      <Detection_Method>
		<Method>Automated Dynamic Analysis</Method>
		<Description>
		  <xhtml:p>Use custom software to change registers that control clock settings or power settings to try to bypass security locks, or repeatedly write DRAM to try to change adjacent locations. This can be effective in extracting or changing data. The drawback is that it cannot be run before manufacturing, and it may require specialized software.</xhtml:p>
		</Description>
		<Effectiveness>Moderate</Effectiveness>
	      </Detection_Method>
	    </Detection_Methods>
            <Potential_Mitigations>
                <Mitigation>
                    <Phase>Architecture and Design</Phase>
                    <Phase>Implementation</Phase>
                    <Description>
                        <xhtml:p>Ensure proper access control mechanisms protect software-controllable features altering physical operating conditions such as clock frequency and voltage.</xhtml:p>
                    </Description>
                </Mitigation>
            </Potential_Mitigations>
            <Demonstrative_Examples>
               <Demonstrative_Example>
                    <Intro_Text>This example considers the Rowhammer problem [REF-1083]. The Rowhammer issue was caused by a program in a tight loop writing repeatedly to a location to which the program was allowed to write but causing an adjacent memory location value to change.</Intro_Text>
                    <Example_Code Nature="Bad" Language="Other">
                        Continuously writing the same value to the same address causes the value of an adjacent location to change value.
                    </Example_Code>
                    <Body_Text>Preventing the loop required to defeat the Rowhammer exploit is not always possible:</Body_Text>
                    <Example_Code Nature="Good" Language="Other">
                        Redesign the RAM devices to reduce inter capacitive coupling making the Rowhammer exploit impossible.
                    </Example_Code>
                    <Body_Text>While the redesign may be possible for new devices, a redesign is not possible in existing devices. There is also the possibility that reducing capacitance with a relayout would impact the density of the device resulting in a less capable, more costly device.</Body_Text>
                </Demonstrative_Example>
                <Demonstrative_Example>
                    <Intro_Text>Suppose a hardware design implements a set of software-accessible registers for scaling clock frequency and voltage but does not control access to these registers. Attackers may cause register and memory changes and race conditions by changing the clock or voltage of the device under their control.</Intro_Text>
                </Demonstrative_Example>
            <Demonstrative_Example>
	      <Intro_Text>Consider the following SoC
	      design. Security-critical settings for scaling clock
	      frequency and voltage are available in a range of
	      registers bounded by [PRIV_END_ADDR : PRIV_START_ADDR]
	      in the tmcu.csr module in the HW Root of Trust. These
	      values are writable based on the lock_bit register in
	      the same module. The lock_bit is only writable by
	      privileged software running on the tmcu.</Intro_Text>
	    <Body_Text>
	    <xhtml:img src="https://cwe.mitre.org/data/images/HRoT-CWE.png" alt="Hardware Root of Trust"/>
	    <xhtml:p>
	      We assume that untrusted software running on any of the
	      Core{0-N} processors has access to the input and output
	      ports of the hrot_iface. If untrusted software can clear
	      the lock_bit or write the clock frequency and voltage
	      registers due to inadequate protection, a fault
	      injection attack could be performed.</xhtml:p>
	    </Body_Text>
            </Demonstrative_Example>
            </Demonstrative_Examples>
            <Observed_Examples>
            	<Observed_Example>
               		<Reference>CVE-2019-11157</Reference>
               		<Description>Plundervolt: Improper conditions check in voltage settings for some Intel(R) Processors may allow a privileged user to potentially enable escalation of privilege and/or information disclosure via local access [REF-1081].</Description>
               		<Link>https://www.cve.org/CVERecord?id=CVE-2019-11157</Link>
           		 </Observed_Example>
               <Observed_Example>
                     <Reference>CVE-2020-8694</Reference>
                     <Description>PLATYPUS Attack: Insufficient access control in the Linux kernel driver for some Intel processors allows information disclosure.</Description>
                     <Link>https://www.cve.org/CVERecord?id=CVE-2020-8694</Link>
                     </Observed_Example>
               <Observed_Example>
                     <Reference>CVE-2020-8695</Reference>
                     <Description>Observable discrepancy in the RAPL interface for some Intel processors allows information disclosure.</Description>
                     <Link>https://www.cve.org/CVERecord?id=CVE-2020-8695</Link>
                     </Observed_Example>
               <Observed_Example>
                     <Reference>CVE-2020-12912</Reference>
                     <Description>AMD extension to a Linux service does not require privileged access to the RAPL interface, allowing side-channel attacks.</Description>
                     <Link>https://www.cve.org/CVERecord?id=CVE-2020-12912</Link>
                     </Observed_Example>
					 <Observed_Example>
               		<Reference>CVE-2015-0565</Reference>
               		<Description>NaCl in 2015 allowed the CLFLUSH instruction, making Rowhammer attacks possible.</Description>
               		<Link>https://www.cve.org/CVERecord?id=CVE-2015-0565</Link>
           		 </Observed_Example>
           	</Observed_Examples>
         <Functional_Areas>
            	<Functional_Area>Power</Functional_Area>
                <Functional_Area>Clock</Functional_Area>
         </Functional_Areas>
         <Related_Attack_Patterns>
            <Related_Attack_Pattern CAPEC_ID="624"/>
            <Related_Attack_Pattern CAPEC_ID="625"/>
         </Related_Attack_Patterns>
         <References>
                <Reference External_Reference_ID="REF-1081"/>
                <Reference External_Reference_ID="REF-1082"/>
                <Reference External_Reference_ID="REF-1083"/>
                <Reference External_Reference_ID="REF-1225"/>
                <Reference External_Reference_ID="REF-1217"/>
            </References>
         <Mapping_Notes>
            <Usage>Allowed</Usage>
            <Rationale>This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.</Rationale>
            <Comments>Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.</Comments>
            <Reasons>
               <Reason Type="Acceptable-Use"/>
            </Reasons>
         </Mapping_Notes>
            <Content_History>
                <Submission>
                    <Submission_Name>Nicole Fern</Submission_Name>
                    <Submission_Organization>Tortuga Logic</Submission_Organization>
                    <Submission_Date>2020-05-08</Submission_Date>
                    <Submission_Version>4.1</Submission_Version>
                    <Submission_ReleaseDate>2020-02-24</Submission_ReleaseDate>
                </Submission>
		<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-08-20</Modification_Date>
					<Modification_Comment>updated Demonstrative_Examples, Description, Maintenance_Notes, Related_Attack_Patterns</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-03-15</Modification_Date>
					<Modification_Comment>updated Demonstrative_Examples, Functional_Areas, Maintenance_Notes</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-07-20</Modification_Date>
					<Modification_Comment>updated Demonstrative_Examples, Observed_Examples</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-10-28</Modification_Date>
					<Modification_Comment>updated Demonstrative_Examples, Description, Detection_Factors, Maintenance_Notes, Modes_of_Introduction, Name, Observed_Examples, References, Relationships, Weakness_Ordinalities</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2022-04-28</Modification_Date>
					<Modification_Comment>updated Applicable_Platforms</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2022-06-28</Modification_Date>
					<Modification_Comment>updated Applicable_Platforms</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-01-31</Modification_Date>
					<Modification_Comment>updated Related_Attack_Patterns</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-04-27</Modification_Date>
					<Modification_Comment>updated Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-06-29</Modification_Date>
					<Modification_Comment>updated Mapping_Notes</Modification_Comment>
				</Modification>
            <Contribution Type="Content">
               <Contribution_Organization>Tortuga Logic</Contribution_Organization>
               <Contribution_Date>2021-07-16</Contribution_Date>
               <Contribution_Comment>Provided Demonstrative Example for Hardware Root of Trust</Contribution_Comment>
            </Contribution>
		<Contribution Type="Content">
		  <Contribution_Name>Anders Nordstrom, Alric Althoff</Contribution_Name>
		  <Contribution_Organization>Tortuga Logic</Contribution_Organization>
		  <Contribution_Date>2021-10-11</Contribution_Date>
		  <Contribution_Comment>Provided detection method</Contribution_Comment>
		</Contribution>
		<Contribution Type="Content">
		  <Contribution_Name>Nicole Fern</Contribution_Name>
		  <Contribution_Organization>Riscure</Contribution_Organization>
		  <Contribution_Date>2021-10-15</Contribution_Date>
		  <Contribution_Comment>updated description and extended description, detection method, and observed examples</Contribution_Comment>
		</Contribution>
			<Previous_Entry_Name Date="2021-10-28">Hardware Features Enable Physical Attacks from Software</Previous_Entry_Name>
            </Content_History>
        </Weakness>
      <Weakness ID="1260" Name="Improper Handling of Overlap Between Protected Memory Ranges" Abstraction="Base" Structure="Simple" Status="Stable">
         <Description>The product allows address regions to overlap, which can result in the bypassing of intended memory protection.</Description>
         <Extended_Description>
            <xhtml:p>Isolated memory regions and access control (read/write) policies are used by hardware to protect privileged software. Software components are often allowed to change or remap memory region definitions in order to enable flexible and dynamically changeable memory management by system software.</xhtml:p>
            <xhtml:p>If a software component running at lower privilege can program a memory address region to overlap with other memory regions used by software running at higher privilege, privilege escalation may be available to attackers. The memory protection unit (MPU) logic can incorrectly handle such an address overlap and allow the lower-privilege software to read or write into the protected memory region, resulting in privilege escalation attack. An address overlap weakness can also be used to launch a denial of service attack on the higher-privilege software memory regions.</xhtml:p>
         </Extended_Description>
			<Related_Weaknesses>
			  <Related_Weakness Nature="ChildOf" CWE_ID="284" View_ID="1000" Ordinal="Primary"/>
			  <Related_Weakness Nature="CanPrecede" CWE_ID="119" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
		 <Weakness_Ordinalities>
            <Weakness_Ordinality>
               <Ordinality>Primary</Ordinality>
            </Weakness_Ordinality>
            <Weakness_Ordinality>
               <Ordinality>Resultant</Ordinality>
            </Weakness_Ordinality>
		 </Weakness_Ordinalities>
         <Applicable_Platforms>
            <Language Class="Not Language-Specific" Prevalence="Undetermined"/>
	    <Operating_System Class="Not OS-Specific" Prevalence="Undetermined"/>
	    <Architecture Class="Not Architecture-Specific" Prevalence="Undetermined"/>
            <Technology Name="Memory Hardware" Prevalence="Undetermined"/>
            <Technology Name="Processor Hardware" Prevalence="Undetermined"/>
         </Applicable_Platforms>
         <Modes_Of_Introduction>
            <Introduction>
               <Phase>Architecture and Design</Phase>
            <Note>Such issues could be introduced during hardware architecture and design or implementation and identified later during the Testing phase.</Note>            
            </Introduction>
            <Introduction>
               <Phase>Implementation</Phase>
            </Introduction>
         </Modes_Of_Introduction>
         <Common_Consequences>
            <Consequence>
               <Scope>Confidentiality</Scope>
               <Scope>Integrity</Scope>
               <Scope>Availability</Scope>
               <Impact>Modify Memory</Impact>
               <Impact>Read Memory</Impact>
               <Impact>DoS: Instability</Impact>
               <Likelihood>High</Likelihood>
            </Consequence>
         </Common_Consequences>
	 <Detection_Methods>
	   <Detection_Method>
	     <Method>Manual Analysis</Method>
	     <Description>Create a high privilege memory block of any arbitrary size. Attempt to create a lower privilege memory block with an overlap of the high privilege memory block. If the creation attempt works, fix the hardware. Repeat the test.</Description>
	     <Effectiveness>High</Effectiveness>
	   </Detection_Method>
	 </Detection_Methods>
         <Potential_Mitigations>
            <Mitigation>
               <Phase>Architecture and Design</Phase>
               <Description>
                   <xhtml:p>Ensure that memory regions are isolated as intended and that access control (read/write) policies are used by hardware to protect privileged software.</xhtml:p>
               </Description>
            </Mitigation>
            <Mitigation> 
               <Phase>Implementation</Phase>
               <Description>
                 <xhtml:p>For all of the programmable memory protection regions, the memory protection unit (MPU) design can define a priority scheme.</xhtml:p>
                 <xhtml:p>For example: if three memory regions can be programmed (Region_0, Region_1, and Region_2), the design can enforce a priority scheme, such that, if a system address is within multiple regions, then the region with the lowest ID takes priority and the access-control policy of that region will be applied.  In some MPU designs, the priority scheme can also be programmed by trusted software.</xhtml:p>
                 <xhtml:p>Hardware logic or trusted firmware can also check for region definitions and block programming of memory regions with overlapping addresses. </xhtml:p>
                 <xhtml:p>The memory-access-control-check filter can also be designed to apply a policy filter to all of the overlapping ranges, i.e., if an address is within Region_0 and Region_1, then access to this address is only granted if both Region_0 and Region_1 policies allow the access.</xhtml:p>
               </Description>
               <Effectiveness>High</Effectiveness>
            </Mitigation>
         </Potential_Mitigations>
         <Demonstrative_Examples>
            <Demonstrative_Example>
	      <Intro_Text>
		<xhtml:p>For example, consider a design with a 16-bit address that has two software privilege levels: Privileged_SW and Non_privileged_SW. To isolate the system memory regions accessible by these two privilege levels, the design supports three memory regions: Region_0, Region_1, and Region_2.</xhtml:p>
		<xhtml:p>Each region is defined by two 32 bit registers: its range and its access policy.</xhtml:p>
		<xhtml:ul>
		  <xhtml:li>Address_range[15:0]: specifies the Base address of the region</xhtml:li>
		  <xhtml:li>Address_range[31:16]: specifies the size of the region</xhtml:li>
		  <xhtml:li>Access_policy[31:0]: specifies what types of software can access a region and which actions are allowed</xhtml:li>
		</xhtml:ul>
		<xhtml:p>Certain bits of the access policy are defined symbolically as follows:</xhtml:p>
		<xhtml:ul>
		  <xhtml:li>Access_policy.read_np: if set to one, allows reads from Non_privileged_SW</xhtml:li>
		  <xhtml:li>Access_policy.write_np: if set to one, allows writes from Non_privileged_SW</xhtml:li>
		  <xhtml:li>Access_policy.execute_np: if set to one, allows code execution by Non_privileged_SW</xhtml:li>
		  <xhtml:li>Access_policy.read_p: if set to one, allows reads from Privileged_SW</xhtml:li>
		  <xhtml:li>Access_policy.write_p: if set to one, allows writes from Privileged_SW</xhtml:li>
		  <xhtml:li>Access_policy.execute_p: if set to one, allows code execution by Privileged_SW</xhtml:li>
		</xhtml:ul>
		<xhtml:p>For any requests from software, an address-protection filter checks the address range and access policies for each of the three regions, and only allows software access if all three filters allow access.</xhtml:p>
		<xhtml:p>Consider the following goals for access control as intended by the designer:</xhtml:p>
		<xhtml:ul>
		  <xhtml:li>Region_0 &amp; Region_1: registers are programmable by Privileged_SW</xhtml:li>
		  <xhtml:li>Region_2: registers are programmable by Non_privileged_SW</xhtml:li>
		</xhtml:ul>
		<xhtml:p>The intention is that Non_privileged_SW cannot modify memory region and policies defined by Privileged_SW in Region_0 and Region_1. Thus, it cannot read or write the memory regions that Privileged_SW is using.</xhtml:p>
	      </Intro_Text>
            <Example_Code Nature="Bad">
               <xhtml:p>Non_privileged_SW can program the Address_range register for Region_2 so that its address overlaps with the ranges defined by Region_0 or Region_1. Using this capability, it is possible for Non_privileged_SW to block any memory region from being accessed by Privileged_SW, i.e., Region_0 and Region_1.</xhtml:p>
            </Example_Code>
	    <Body_Text>This design could be improved in several ways.</Body_Text>
            <Example_Code Nature="Good">Ensure that software accesses to memory regions are only permitted if all three filters permit access. Additionally, the scheme could define a memory region priority to ensure that Region_2 (the memory region defined by Non_privileged_SW) cannot overlap Region_0 or Region_1 (which are used by Privileged_SW).</Example_Code>
	    </Demonstrative_Example>
		    <Demonstrative_Example>
               <Intro_Text>The example code below is taken from the IOMMU controller module of the HACK@DAC'19 buggy CVA6 SoC [REF-1338]. The static memory map is composed of a set of Memory-Mapped Input/Output (MMIO) regions covering different IP agents within the SoC. Each region is defined by two 64-bit variables representing the base address and size of the memory region (XXXBase and XXXLength).</Intro_Text>
               <Body_Text>In this example, we have 12 IP agents, and only 4 of them are called out for illustration purposes in the code snippets. Access to the AES IP MMIO region is considered privileged as it provides access to AES secret key, internal states, or decrypted data.</Body_Text>
			   <Example_Code Nature="Bad" Language="Verilog">
                	<xhtml:div>...
						<xhtml:div style="margin-left:1em;">
							localparam logic[63:0] PLICLength = 64'h03FF_FFFF;<xhtml:br/>
							<xhtml:b>localparam logic[63:0] UARTLength = 64'h0011_1000;</xhtml:b><xhtml:br/>
							<xhtml:b>localparam logic[63:0] AESLength = 64'h0000_1000;</xhtml:b><xhtml:br/>
							localparam logic[63:0] SPILength = 64'h0080_0000;<xhtml:br/>
						</xhtml:div>
						<xhtml:div>...<xhtml:br/></xhtml:div>
						<xhtml:div style="margin-left:1em;">
							typedef enum logic [63:0] {<xhtml:br/>
							<xhtml:div style="margin-left:1em;">
								...<xhtml:br/>
								PLICBase = 64'h0C00_0000,<xhtml:br/>
								<xhtml:b>UARTBase = 64'h1000_0000,</xhtml:b><xhtml:br/>
								<xhtml:b>AESBase = 64'h1010_0000,</xhtml:b><xhtml:br/>
								SPIBase = 64'h2000_0000,<xhtml:br/>
								...<xhtml:br/>
							</xhtml:div>
						</xhtml:div>       
                	</xhtml:div>
               </Example_Code>
               <Body_Text>The vulnerable code allows the overlap between the protected MMIO region of the AES peripheral and the unprotected UART MMIO region. As a result, unprivileged users can access the protected region of the AES IP. In the given vulnerable example UART MMIO region starts at address 64'h1000_0000 and ends at address 64'h1011_1000 (UARTBase is 64'h1000_0000, and the size of the region is provided by the UARTLength of 64'h0011_1000).</Body_Text>
			   <Body_Text>On the other hand, the AES MMIO region starts at address 64'h1010_0000 and ends at address 64'h1010_1000, which implies an overlap between the two peripherals' memory regions. Thus, any user with access to the UART can read or write the AES MMIO region, e.g., the AES secret key.</Body_Text>
				<Body_Text>To mitigate this issue, remove the overlapping address regions by decreasing the size of the UART memory region or adjusting memory bases for all the remaining peripherals. [REF-1339]</Body_Text>
				<Example_Code Nature="Good" Language="Verilog">
					<xhtml:div>...
						<xhtml:div style="margin-left:1em;">
							localparam logic[63:0] PLICLength = 64'h03FF_FFFF;<xhtml:br/>
							<xhtml:b>localparam logic[63:0] UARTLength = 64'h0000_1000;</xhtml:b><xhtml:br/>
							localparam logic[63:0] AESLength = 64'h0000_1000;<xhtml:br/>
							localparam logic[63:0] SPILength = 64'h0080_0000;<xhtml:br/>
						</xhtml:div>
					<xhtml:div>...<xhtml:br/></xhtml:div>
						<xhtml:div style="margin-left:1em;">
							typedef enum logic [63:0] {<xhtml:br/>
							<xhtml:div style="margin-left:1em;">
								...<xhtml:br/>
								PLICBase = 64'h0C00_0000,<xhtml:br/>
								UARTBase = 64'h1000_0000,<xhtml:br/>
								AESBase = 64'h1010_0000,<xhtml:br/>
								SPIBase = 64'h2000_0000,<xhtml:br/>
								...<xhtml:br/>
							</xhtml:div>
						</xhtml:div>       
					</xhtml:div>
               </Example_Code>
			</Demonstrative_Example>
         </Demonstrative_Examples>
         <Observed_Examples>
            <Observed_Example>
               <Reference>CVE-2008-7096</Reference>
               <Description>virtualization product allows compromise of hardware product by accessing certain remapping registers.</Description>
               <Link>https://www.cve.org/CVERecord?id=CVE-2008-7096</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>[REF-1100]</Reference>
               <Description>processor design flaw allows ring 0 code to access more privileged rings by causing a register window to overlap a range of protected system RAM [REF-1100]</Description>
               <Link>https://github.com/xoreaxeaxeax/sinkhole/blob/master/us-15-Domas-TheMemorySinkhole-wp.pdf</Link>
            </Observed_Example>
			</Observed_Examples>
         <Related_Attack_Patterns>
            <Related_Attack_Pattern CAPEC_ID="456"/>
            <Related_Attack_Pattern CAPEC_ID="679"/>
         </Related_Attack_Patterns>
         <References>
         <Reference External_Reference_ID="REF-1100"/>
		 <Reference External_Reference_ID="REF-1338"/>
		 <Reference External_Reference_ID="REF-1339"/>
      </References>
         <Mapping_Notes>
            <Usage>Allowed</Usage>
            <Rationale>This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.</Rationale>
            <Comments>Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.</Comments>
            <Reasons>
               <Reason Type="Acceptable-Use"/>
            </Reasons>
         </Mapping_Notes>
      <Notes>
	<Note Type="Maintenance">As of CWE 4.6, CWE-1260 and CWE-1316 are siblings under view 1000, but CWE-1260 might be a parent of CWE-1316. More analysis is warranted.</Note>
      </Notes>
         <Content_History>
            <Submission>
               <Submission_Name>Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi</Submission_Name>
               <Submission_Organization>Intel Corporation</Submission_Organization>
               <Submission_Date>2020-02-10</Submission_Date>
               <Submission_Version>4.1</Submission_Version>
               <Submission_ReleaseDate>2020-02-24</Submission_ReleaseDate>
            </Submission>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-08-20</Modification_Date>
					<Modification_Comment>updated Demonstrative_Examples, Description, Modes_of_Introduction, Related_Attack_Patterns</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-12-10</Modification_Date>
					<Modification_Comment>updated Maintenance_Notes</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-10-28</Modification_Date>
					<Modification_Comment>updated Demonstrative_Examples, Description, Detection_Factors, Maintenance_Notes, Observed_Examples, Relationships, Weakness_Ordinalities</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2022-04-28</Modification_Date>
					<Modification_Comment>updated Applicable_Platforms, Related_Attack_Patterns</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2022-06-28</Modification_Date>
					<Modification_Comment>updated Applicable_Platforms</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-01-31</Modification_Date>
					<Modification_Comment>updated Related_Attack_Patterns</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-04-27</Modification_Date>
					<Modification_Comment>updated Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-06-29</Modification_Date>
					<Modification_Comment>updated Demonstrative_Examples, Mapping_Notes, References</Modification_Comment>
				</Modification>
				<Contribution Type="Feedback">
				  <Contribution_Name>Narasimha Kumar V Mangipudi</Contribution_Name>
				  <Contribution_Organization>Lattice Semiconductor</Contribution_Organization>
				  <Contribution_Date>2021-10-20</Contribution_Date>
				  <Contribution_Comment>suggested content improvements</Contribution_Comment>
				</Contribution>
				<Contribution Type="Content">
				  <Contribution_Name>Hareesh Khattri</Contribution_Name>
				  <Contribution_Organization>Intel Corporation</Contribution_Organization>
				  <Contribution_Date>2021-10-22</Contribution_Date>
				  <Contribution_Comment>suggested observed examples</Contribution_Comment>
				</Contribution>
				<Contribution Type="Content">
				  <Contribution_Name>Shaza Zeitouni, Mohamadreza Rostami, Pouya Mahmoody, Ahmad-Reza Sadeghi</Contribution_Name>
				  <Contribution_Organization>Technical University of Darmstadt</Contribution_Organization>
				  <Contribution_Date>2023-06-21</Contribution_Date>
				  <Contribution_Comment>suggested demonstrative example</Contribution_Comment>
				</Contribution>
				<Contribution Type="Content">
				  <Contribution_Name>Rahul Kande, Chen Chen, Jeyavijayan Rajendran</Contribution_Name>
				  <Contribution_Organization>Texas A&amp;M University</Contribution_Organization>
				  <Contribution_Date>2023-06-21</Contribution_Date>
				  <Contribution_Comment>suggested demonstrative example</Contribution_Comment>
				</Contribution>
         </Content_History>
      </Weakness>
      <Weakness ID="1272" Name="Sensitive Information Uncleared Before Debug/Power State Transition" Abstraction="Base" Structure="Simple" Status="Stable">
			<Description>The product performs a power or debug state transition, but it does not clear sensitive information that should no longer be accessible due to changes to information access restrictions.</Description>
			<Extended_Description>
				<xhtml:p>A device or system frequently employs many power and sleep states during its normal operation (e.g., normal power, additional power, low power, hibernate, deep sleep, etc.). A device also may be operating within a debug condition. State transitions can happen from one power or debug state to another. If there is information available in the previous state which should not be available in the next state and is not properly removed before the transition into the next state, sensitive information may leak from the system.</xhtml:p>
			</Extended_Description>
     <Related_Weaknesses>
      <Related_Weakness Nature="ChildOf" CWE_ID="226" View_ID="1000" Ordinal="Primary"/>
      <Related_Weakness Nature="CanPrecede" CWE_ID="200" View_ID="1000" Ordinal="Primary"/>
     </Related_Weaknesses>
		 <Weakness_Ordinalities>
            <Weakness_Ordinality>
               <Ordinality>Primary</Ordinality>
            </Weakness_Ordinality>
		 </Weakness_Ordinalities>
			<Applicable_Platforms>
				<Language Name="VHDL" Prevalence="Undetermined"/>
				<Language Name="Verilog" Prevalence="Undetermined"/>
				<Language Class="Hardware Description Language" Prevalence="Undetermined"/>
				<Operating_System Class="Not OS-Specific" Prevalence="Undetermined"/>
				<Architecture Class="Not Architecture-Specific" Prevalence="Undetermined"/>
				<Technology Class="Not Technology-Specific" Prevalence="Undetermined"/>
				</Applicable_Platforms>
			<Modes_Of_Introduction>
				<Introduction>
					<Phase>Architecture and Design</Phase>
				</Introduction>
			</Modes_Of_Introduction>
			<Common_Consequences>
				<Consequence>
					<Scope>Confidentiality</Scope>
					<Scope>Integrity</Scope>
					<Scope>Availability</Scope>
					<Scope>Access Control</Scope>
					<Scope>Accountability</Scope>
					<Scope>Authentication</Scope>
					<Scope>Authorization</Scope>
					<Scope>Non-Repudiation</Scope>
					<Impact>Read Memory</Impact>
					<Impact>Read Application Data</Impact>
					<Likelihood>High</Likelihood>
					<Note>Sensitive information may be used to unlock additional capabilities of the device and take advantage of hidden functionalities which could be used to compromise device security.</Note>
				</Consequence>
			</Common_Consequences>
			<Detection_Methods>
			  <Detection_Method>
			    <Method>Manual Analysis</Method>
			    <Description>Write a known pattern into each sensitive location. Enter the power/debug state in question. Read data back from the sensitive locations. If the reads are successful, and the data is the same as the pattern that was originally written, the test fails and the device needs to be fixed. Note that this test can likely be automated.</Description>
			    <Effectiveness>High</Effectiveness>
			  </Detection_Method>
			</Detection_Methods>
			<Potential_Mitigations>
				<Mitigation>
					<Phase>Architecture and Design</Phase>
					<Phase>Implementation</Phase>
					<Description>During state transitions, information not needed in the next state should be removed before the transition to the next state.</Description>
				</Mitigation>
			</Potential_Mitigations>
			<Demonstrative_Examples>
       <Demonstrative_Example Demonstrative_Example_ID="DX-147">
	 <Intro_Text>This example shows how an attacker can take advantage of an incorrect state transition.</Intro_Text>
	 <Body_Text>
	   <xhtml:p>Suppose a device is transitioning from state A to state B. During state A, it can read certain private keys from the hidden fuses that are only accessible in state A but not in state B. The device reads the keys, performs operations using those keys, then transitions to state B, where those private keys should no longer be accessible.</xhtml:p>
	 </Body_Text>
	 <Example_Code Nature="Bad">
	   <xhtml:p>During the transition from A to B, the device does not scrub the memory.</xhtml:p>
	 </Example_Code>
	 <Body_Text><xhtml:p>After the transition to state B, even though the private keys are no longer accessible directly from the fuses in state B, they can be accessed indirectly by reading the memory that contains the private keys.</xhtml:p></Body_Text>
	 <Example_Code Nature="Good">For transition from state A to state B, remove information which should not be available once the transition is complete.</Example_Code>
       </Demonstrative_Example>
     </Demonstrative_Examples>
			<Observed_Examples>
			  <Observed_Example>
				<Reference>CVE-2020-12926</Reference>
				<Description>Product software does not set a flag as per TPM specifications, thereby preventing a failed authorization attempt from being recorded after a loss of power.</Description>
				<Link>https://www.cve.org/CVERecord?id=CVE-2020-12926</Link>
			  </Observed_Example>
			</Observed_Examples>
		<Functional_Areas>
            <Functional_Area>Power</Functional_Area>
        </Functional_Areas>
         <Related_Attack_Patterns>
            <Related_Attack_Pattern CAPEC_ID="150"/>
            <Related_Attack_Pattern CAPEC_ID="37"/>
            <Related_Attack_Pattern CAPEC_ID="545"/>
            <Related_Attack_Pattern CAPEC_ID="546"/>
         </Related_Attack_Patterns>
         <References>
		   <Reference External_Reference_ID="REF-1220"/>
		 </References>
         <Mapping_Notes>
            <Usage>Allowed</Usage>
            <Rationale>This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.</Rationale>
            <Comments>Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.</Comments>
            <Reasons>
               <Reason Type="Acceptable-Use"/>
            </Reasons>
         </Mapping_Notes>
         <Content_History>
				<Submission>
					<Submission_Name>Parbati Kumar Manna, Hareesh Khattri, Arun Kanuparthi</Submission_Name>
					<Submission_Organization>Intel Corporation</Submission_Organization>
					<Submission_Date>2020-05-31</Submission_Date>
					<Submission_Version>4.1</Submission_Version>
					<Submission_ReleaseDate>2020-02-24</Submission_ReleaseDate>
				</Submission>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-08-20</Modification_Date>
					<Modification_Comment>updated Applicable_Platforms, Common_Consequences, Demonstrative_Examples, Description, Name, Potential_Mitigations, Related_Attack_Patterns, Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-03-15</Modification_Date>
					<Modification_Comment>updated Functional_Areas</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-10-28</Modification_Date>
					<Modification_Comment>updated Common_Consequences, Demonstrative_Examples, Description, Detection_Factors, Observed_Examples, Potential_Mitigations, References, Relationships, Weakness_Ordinalities</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2022-10-13</Modification_Date>
					<Modification_Comment>updated Applicable_Platforms</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-04-27</Modification_Date>
					<Modification_Comment>updated Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-06-29</Modification_Date>
					<Modification_Comment>updated Mapping_Notes</Modification_Comment>
				</Modification>
			<Previous_Entry_Name Date="2020-08-20">Debug/Power State Transitions Leak Information</Previous_Entry_Name>
			</Content_History>
		</Weakness>
      <Weakness ID="1274" Name="Improper Access Control for Volatile Memory Containing Boot Code" Abstraction="Base" Structure="Simple" Status="Stable">
			<Description>The product conducts a secure-boot process that transfers bootloader code from Non-Volatile Memory (NVM) into Volatile Memory (VM), but it does not have sufficient access control or other protections for the Volatile Memory.</Description>
			<Extended_Description>
			  <xhtml:p>Adversaries could bypass the secure-boot process and execute their own untrusted, malicious boot code.</xhtml:p>
			  <xhtml:p>As a part of a secure-boot process, the read-only-memory (ROM) code for a System-on-Chip (SoC) or other system fetches bootloader code from Non-Volatile Memory (NVM) and stores the code in Volatile Memory (VM), such as dynamic, random-access memory (DRAM) or static, random-access memory (SRAM). The NVM is usually external to the SoC, while the VM is internal to the SoC. As the code is transferred from NVM to VM, it is authenticated by the SoC's ROM code.</xhtml:p>
			  <xhtml:p>If the volatile-memory-region protections or access controls are insufficient to prevent modifications from an adversary or untrusted agent, the secure boot may be bypassed or replaced with the execution of an adversary's code.</xhtml:p>
			</Extended_Description>
			<Related_Weaknesses>
			  <Related_Weakness Nature="ChildOf" CWE_ID="284" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
		 <Weakness_Ordinalities>
            <Weakness_Ordinality>
               <Ordinality>Primary</Ordinality>
            </Weakness_Ordinality>
		 </Weakness_Ordinalities>
			<Applicable_Platforms>
				<Language Class="Not Language-Specific" Prevalence="Undetermined"/>
				<Operating_System Class="Not OS-Specific" Prevalence="Undetermined"/>
				<Architecture Class="Not Architecture-Specific" Prevalence="Undetermined"/>
				<Technology Class="Not Technology-Specific" Prevalence="Undetermined"/>
				</Applicable_Platforms>
			<Modes_Of_Introduction>
				<Introduction>
					<Phase>Architecture and Design</Phase>
					<Note>This weakness can be introduced during hardware architecture or design but can be identified later during testing.</Note>
				</Introduction>
			</Modes_Of_Introduction>
			<Common_Consequences>
				<Consequence>
					<Scope>Access Control</Scope>
					<Scope>Integrity</Scope>
					<Impact>Modify Memory</Impact>
					<Impact>Execute Unauthorized Code or Commands</Impact>
					<Impact>Gain Privileges or Assume Identity</Impact>
					<Likelihood>High</Likelihood>
				</Consequence>
			</Common_Consequences>
			<Detection_Methods>
			  <Detection_Method>
			    <Method>Manual Analysis</Method>
			    <Description>Ensure the volatile memory is lockable or has locks. Ensure the volatile memory is locked for writes from untrusted agents or adversaries. Try modifying the volatile memory from an untrusted agent, and ensure these writes are dropped.
			     </Description>
			    <Effectiveness>High</Effectiveness>
			  </Detection_Method>
			  <Detection_Method>
			    <Method>Manual Analysis</Method>
			    <Description>
			      <xhtml:p>Analyze the device using the following steps:</xhtml:p>
			      <xhtml:ol>
				<xhtml:li>Identify all fabric master agents that are active during system Boot Flow when initial code is loaded from Non-volatile storage to volatile memory.</xhtml:li>
				<xhtml:li>Identify the volatile memory regions that are used for storing loaded system executable program.</xhtml:li>
				<xhtml:li>During system boot, test programming the identified memory regions in step 2 from all the masters identified in step 1.</xhtml:li>
			      </xhtml:ol>
			      <xhtml:p>Only trusted masters should be allowed to write to the memory regions. For example, pluggable device peripherals should not have write access to program load memory regions.</xhtml:p>
			    </Description>
			    <Effectiveness>Moderate</Effectiveness>
			  </Detection_Method>
			</Detection_Methods>
			<Potential_Mitigations>
				<Mitigation>
					<Phase>Architecture and Design</Phase>
					<Description>Ensure that the design of volatile-memory protections is enough to prevent modification from an adversary or untrusted code.</Description>
				</Mitigation>
				<Mitigation>
					<Phase>Testing</Phase>
					<Description>Test the volatile-memory protections to ensure they are safe from modification or untrusted code.</Description>
				</Mitigation>
			</Potential_Mitigations>
			<Demonstrative_Examples>
				<Demonstrative_Example>
					<Intro_Text>A typical SoC secure boot's flow includes fetching the next piece of code (i.e., the boot loader) from NVM (e.g., serial, peripheral interface (SPI) flash), and transferring it to DRAM/SRAM volatile, internal memory, which is more efficient.</Intro_Text>
					<Example_Code Nature="Bad">The volatile-memory protections or access controls are insufficient.</Example_Code>
					<Body_Text>The memory from where the boot loader executes can be modified by an adversary.</Body_Text>
					<Example_Code Nature="Good">A good architecture should define appropriate protections or access controls to prevent modification by an adversary or untrusted agent, once the bootloader is authenticated.</Example_Code>
				</Demonstrative_Example>
			</Demonstrative_Examples>
			<Observed_Examples>
				<Observed_Example>
					<Reference>CVE-2019-2267</Reference>
					<Description>Locked memory regions may be modified through other interfaces in a secure-boot-loader image due to improper access control.</Description>
					<Link>https://www.cve.org/CVERecord?id=CVE-2019-2267</Link>
				</Observed_Example>
			</Observed_Examples>
         <Related_Attack_Patterns>
            <Related_Attack_Pattern CAPEC_ID="456"/>
            <Related_Attack_Pattern CAPEC_ID="679"/>
         </Related_Attack_Patterns>
         <Mapping_Notes>
            <Usage>Allowed</Usage>
            <Rationale>This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.</Rationale>
            <Comments>Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.</Comments>
            <Reasons>
               <Reason Type="Acceptable-Use"/>
            </Reasons>
         </Mapping_Notes>
         <Content_History>
				<Submission>
					<Submission_Name>Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi</Submission_Name>
					<Submission_Organization>Intel Corporation</Submission_Organization>
					<Submission_Date>2020-04-25</Submission_Date>
					<Submission_Version>4.1</Submission_Version>
					<Submission_ReleaseDate>2020-02-24</Submission_ReleaseDate>
				</Submission>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-08-20</Modification_Date>
					<Modification_Comment>updated Demonstrative_Examples, Description, Related_Attack_Patterns</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-10-28</Modification_Date>
					<Modification_Comment>updated Common_Consequences, Demonstrative_Examples, Description, Detection_Factors, Maintenance_Notes, Name, Observed_Examples, Potential_Mitigations, Relationships, Weakness_Ordinalities</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2022-04-28</Modification_Date>
					<Modification_Comment>updated Related_Attack_Patterns</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-01-31</Modification_Date>
					<Modification_Comment>updated Related_Attack_Patterns</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-04-27</Modification_Date>
					<Modification_Comment>updated Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-06-29</Modification_Date>
					<Modification_Comment>updated Mapping_Notes</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2024-02-29</Modification_Date>
					<Modification_Version>4.14</Modification_Version>
					<Modification_ReleaseDate>2024-02-29</Modification_ReleaseDate>
					<Modification_Comment>updated Detection_Factors</Modification_Comment>
				</Modification>
				<Contribution Type="Feedback">
				  <Contribution_Name>Narasimha Kumar V Mangipudi</Contribution_Name>
				  <Contribution_Organization>Lattice Semiconductor</Contribution_Organization>
				  <Contribution_Date>2021-10-20</Contribution_Date>
				  <Contribution_Comment>suggested content improvements</Contribution_Comment>
				</Contribution>
				<Contribution Type="Content">
				  <Contribution_Name>Hareesh Khattri</Contribution_Name>
				  <Contribution_Organization>Intel Corporation</Contribution_Organization>
				  <Contribution_Date>2021-10-22</Contribution_Date>
				  <Contribution_Comment>provided detection method</Contribution_Comment>
				</Contribution>
			<Previous_Entry_Name Date="2021-10-28">Insufficient Protections on the Volatile Memory Containing Boot Code</Previous_Entry_Name>
			</Content_History>
		</Weakness>
      <Weakness ID="1277" Name="Firmware Not Updateable" Abstraction="Base" Structure="Simple" Status="Draft">
			<Description>The product does not provide its
			users with the ability to update or patch its
			firmware to address any vulnerabilities or
			weaknesses that may be present.</Description>
			<Extended_Description>Without the ability to
			patch or update firmware, consumers will be
			left vulnerable to exploitation of any known
			vulnerabilities, or any vulnerabilities that
			are discovered in the future. This can expose
			consumers to permanent risk throughout the
			entire lifetime of the device, which could be
			years or decades. Some external protective
			measures and mitigations might be employed to
			aid in preventing or reducing the risk of
			malicious attack, but the root weakness cannot
			be corrected.</Extended_Description>
			<Related_Weaknesses>
			  <Related_Weakness Nature="ChildOf" CWE_ID="1329" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
		 <Weakness_Ordinalities>
            <Weakness_Ordinality>
               <Ordinality>Primary</Ordinality>
            </Weakness_Ordinality>
		 </Weakness_Ordinalities>
			<Applicable_Platforms>	
				<Language Class="Not Language-Specific" Prevalence="Undetermined"/>
				<Operating_System Class="Not OS-Specific" Prevalence="Undetermined"/>
				<Architecture Class="Not Architecture-Specific" Prevalence="Undetermined"/>
				<Technology Class="Not Technology-Specific" Prevalence="Undetermined"/>
				</Applicable_Platforms>
			<Modes_Of_Introduction>
				<Introduction>
					<Phase>Requirements</Phase>
					<Note>Requirements development might not consider the importance of updates over the lifetime of the product, or might not choose the ability due to concerns such as expense or speed to market.</Note>
				</Introduction>
				<Introduction>
					<Phase>Architecture and Design</Phase>
					<Note>Lack of planning during architecture development and design, or external pressures such as speed to market, could ignore the capability to update.</Note>
				</Introduction>
				<Introduction>
					<Phase>Implementation</Phase>
					<Note>The weakness can appear through oversight during implementation.</Note>
				</Introduction>
			</Modes_Of_Introduction>
			<Common_Consequences>
				<Consequence>
					<Scope>Confidentiality</Scope>
					<Scope>Integrity</Scope>
					<Scope>Access Control</Scope>
					<Scope>Authentication</Scope>
					<Scope>Authorization</Scope>
					<Impact>Gain Privileges or Assume Identity</Impact>
					<Impact>Bypass Protection Mechanism</Impact>
					<Impact>Execute Unauthorized Code or Commands</Impact>
					<Impact>DoS: Crash, Exit, or Restart</Impact>
					<Likelihood>Medium</Likelihood>
					<Note>If an attacker can identify an exploitable vulnerability in one device that has no means of patching, the attack may be used against an entire class of devices.</Note>
				</Consequence>
			</Common_Consequences>
			<Detection_Methods>
			  <Detection_Method>
			    <Method>Manual Analysis</Method>
			    <Description>Create a new installable boot image of the current build with a minor version number change. Use the standard installation method to update the boot image. Verify that the minor version number has changed. Create a fake image. Verify that the boot updater will not install the fake image and generates an "invalid image" error message or equivalent.</Description>
			    <Effectiveness>High</Effectiveness>
			  </Detection_Method>
			  <Detection_Method>
			    <Method>Architecture or Design Review</Method>
			    <Description>Check the consumer or maintainer documentation, the architecture/design documentation, or the original requirements to ensure that the documentation includes details for how to update the firmware.</Description>
			    <Effectiveness>Moderate</Effectiveness>
			  </Detection_Method>
			  <Detection_Method>
			    <Method>Manual Dynamic Analysis</Method>
			    <Description>Determine if there is a lack of a capability to update read-only memory (ROM) structure. This could manifest as a difference between the latest firmware version and the current version within the device.</Description>
			    <Effectiveness>High</Effectiveness>
			  </Detection_Method>
			</Detection_Methods>
			<Potential_Mitigations>
				<Mitigation>
					<Phase>Requirements</Phase>
					<Description>Specify requirements to include the ability to update the firmware. Include integrity checks and authentication to ensure that untrusted firmware cannot be installed.</Description>
				</Mitigation>
				<Mitigation>
					<Phase>Architecture and Design</Phase>
					<Description>Design the device to allow for updating the firmware. Ensure that the design specifies how to distribute the updates and ensure their integrity and authentication.</Description>
				</Mitigation>
				<Mitigation>
					<Phase>Implementation</Phase>
					<Description>Implement the necessary functionality to allow the firmware to be updated.</Description>
				</Mitigation>
			</Potential_Mitigations>
			<Demonstrative_Examples>
				<Demonstrative_Example Demonstrative_Example_ID="DX-145">
					<Intro_Text>A refrigerator has an Internet interface for the official purpose of alerting the manufacturer when that refrigerator detects a fault. Because the device is attached to the Internet, the refrigerator is a target for hackers who may wish to use the device other potentially more nefarious purposes.</Intro_Text>
					<Example_Code Nature="Bad" Language="Other">The refrigerator has no means of patching and is hacked becoming a spewer of email spam.</Example_Code>
					<Example_Code Nature="Good" Language="Other">The device automatically patches itself and provides considerable more protection against being hacked.</Example_Code>
				</Demonstrative_Example>
			</Demonstrative_Examples>
			<Observed_Examples>
      			  <Observed_Example>
        		    <Reference>CVE-2020-9054</Reference>
        		    <Description>Chain: network-attached storage (NAS) device has a critical OS command injection (CWE-78) vulnerability that is actively exploited to place IoT devices into a botnet, but some products are "end-of-support" and cannot be patched (CWE-1277). [REF-1097]</Description>
        		    <Link>https://www.cve.org/CVERecord?id=CVE-2020-9054</Link>
      			  </Observed_Example>
			  <Observed_Example>
			    <Reference>[REF-1095]</Reference>
			    <Description>A hardware "smart lock" has weak key generation that allows attackers to steal the key by BLE sniffing, but the device's firmware cannot be upgraded and hence remains vulnerable [REF-1095].</Description>
			    <Link>https://www.theregister.com/2019/12/11/f_secure_keywe/</Link>
      			  </Observed_Example>
      			</Observed_Examples>
         <Related_Attack_Patterns>
            <Related_Attack_Pattern CAPEC_ID="682"/>
         </Related_Attack_Patterns>
         <References>
				<Reference External_Reference_ID="REF-1095"/>
				<Reference External_Reference_ID="REF-1096"/>
				<Reference External_Reference_ID="REF-1097"/>
			</References>
         <Mapping_Notes>
            <Usage>Allowed</Usage>
            <Rationale>This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.</Rationale>
            <Comments>Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.</Comments>
            <Reasons>
               <Reason Type="Acceptable-Use"/>
            </Reasons>
         </Mapping_Notes>
			<Notes>
                <Note Type="Terminology">The "firmware" term does not have a single commonly-shared definition, so there may be variations in how this CWE entry is interpreted during mapping.</Note>
            </Notes>
			<Content_History>
				<Submission>
					<Submission_Name>Paul A. Wortman</Submission_Name>
					<Submission_Organization>Wells Fargo</Submission_Organization>
					<Submission_Date>2020-05-13</Submission_Date>
					<Submission_Version>4.1</Submission_Version>
					<Submission_ReleaseDate>2020-02-24</Submission_ReleaseDate>
				</Submission>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-08-20</Modification_Date>
					<Modification_Comment>updated Common_Consequences, Demonstrative_Examples, Description, Potential_Mitigations</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-12-10</Modification_Date>
					<Modification_Comment>updated Description, Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-03-15</Modification_Date>
					<Modification_Comment>updated Maintenance_Notes</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-07-20</Modification_Date>
					<Modification_Comment>updated Demonstrative_Examples, Maintenance_Notes</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-10-28</Modification_Date>
					<Modification_Comment>updated Common_Consequences, Description, Detection_Factors, Maintenance_Notes, Modes_of_Introduction, Observed_Examples, References, Relationships, Terminology_Notes, Weakness_Ordinalities</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2022-04-28</Modification_Date>
					<Modification_Comment>updated Detection_Factors, Observed_Examples, Potential_Mitigations, Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2022-10-13</Modification_Date>
					<Modification_Comment>updated Related_Attack_Patterns</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-04-27</Modification_Date>
					<Modification_Comment>updated Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-06-29</Modification_Date>
					<Modification_Comment>updated Mapping_Notes</Modification_Comment>
				</Modification>
            <Contribution Type="Content">
	      <Contribution_Name>Paul A. Wortman</Contribution_Name>
               <Contribution_Organization>Wells Fargo</Contribution_Organization>
               <Contribution_Date>2021-10-12</Contribution_Date>
               <Contribution_Comment>provided detection methods and observed examples</Contribution_Comment>
            </Contribution>
			</Content_History>
		</Weakness>
      <Weakness ID="1300" Name="Improper Protection of Physical Side Channels" Abstraction="Base" Structure="Simple" Status="Stable">

	<Description>The device does not contain sufficient protection
	mechanisms to prevent physical side channels from exposing
	sensitive information due to patterns in physically observable
	phenomena such as variations in power consumption,
	electromagnetic emissions (EME), or acoustic emissions.</Description>
			
	<Extended_Description>
	  <xhtml:p>An adversary could monitor and measure physical
	  phenomena to detect patterns and make inferences, even if it
	  is not possible to extract the information in the digital
	  domain.</xhtml:p>
	  <xhtml:p>Physical side channels have been well-studied for
	  decades in the context of breaking implementations of
	  cryptographic algorithms or other attacks against security
	  features. These side channels may be easily observed by an
	  adversary with physical access to the device, or using a
	  tool that is in close proximity.  If the adversary can
	  monitor hardware operation and correlate its data processing
	  with power, EME, and acoustic measurements, the adversary
	  might be able to recover of secret keys and data.</xhtml:p>
			</Extended_Description>
			<Related_Weaknesses>
				<Related_Weakness Nature="ChildOf" CWE_ID="203" View_ID="1000" Ordinal="Primary"/>
				<Related_Weakness Nature="ChildOf" CWE_ID="203" View_ID="1194" Ordinal="Primary"/>
			</Related_Weaknesses>
		 <Weakness_Ordinalities>
            <Weakness_Ordinality>
               <Ordinality>Primary</Ordinality>
            </Weakness_Ordinality>
            <Weakness_Ordinality>
               <Ordinality>Resultant</Ordinality>
            </Weakness_Ordinality>
		 </Weakness_Ordinalities>
			<Applicable_Platforms>
				<Language Class="Not Language-Specific" Prevalence="Undetermined"/>
				<Operating_System Class="Not OS-Specific" Prevalence="Undetermined"/>
				<Architecture Class="Not Architecture-Specific" Prevalence="Undetermined"/>
				<Technology Class="Not Technology-Specific" Prevalence="Undetermined"/>
				</Applicable_Platforms>
			<Modes_Of_Introduction>
				<Introduction>
					<Phase>Implementation</Phase>
				</Introduction>
			</Modes_Of_Introduction>
			<Common_Consequences>
				<Consequence>
					<Scope>Confidentiality</Scope>
					<Impact>Read Memory</Impact>
					<Impact>Read Application Data</Impact>
				</Consequence>
			</Common_Consequences>
			<Detection_Methods>
			  <Detection_Method>
				<Method>Manual Analysis</Method>
				<Description>Perform a set of leakage detection tests such as the procedure outlined in the Test Vector Leakage Assessment (TVLA) test requirements for AES [REF-1230].  TVLA is the basis for the ISO standard 17825 [REF-1229]. A separate methodology is provided by [REF-1228]. Note that sole reliance on this method might not yield expected results [REF-1239] [REF-1240].</Description>
				<Effectiveness>Moderate</Effectiveness>
			  </Detection_Method>
			  <Detection_Method>
				<Method>Manual Analysis</Method>
				<Description>
				  <xhtml:p>Post-silicon, perform full side-channel attacks (penetration testing) covering as many known leakage models as possible against test code.</xhtml:p></Description>
				  <Effectiveness>Moderate</Effectiveness>
				</Detection_Method>
			  <Detection_Method>
				<Method>Manual Analysis</Method>
				<Description>
				  <xhtml:p>Pre-silicon - while the aforementioned TVLA methods can be performed post-silicon, models of device power consumption or other physical emanations can be built from information present at various stages of the hardware design process before fabrication. TVLA or known side-channel attacks can be applied to these simulated traces and countermeasures applied before tape-out.  Academic research in this field includes [REF-1231] [REF-1232] [REF-1233].</xhtml:p></Description>
				  <Effectiveness>Moderate</Effectiveness>
				</Detection_Method>
			  </Detection_Methods>
			<Potential_Mitigations>
				<Mitigation>
					<Phase>Architecture and Design</Phase>
					<Description>Apply blinding or masking techniques to implementations of cryptographic algorithms.</Description>
				</Mitigation>
				<Mitigation>
					<Phase>Implementation</Phase>
					<Description>Add shielding or tamper-resistant protections to the device to increase the difficulty of obtaining measurements of the side-channel.</Description>
				</Mitigation>
			</Potential_Mitigations>
		<Demonstrative_Examples>
		  <Demonstrative_Example>
		    <Intro_Text>Consider a device that checks a
		    passcode to unlock the screen.</Intro_Text>
		    <Example_Code Nature="Bad">As each character of
		    the PIN number is entered, a correct character
		    exhibits one current pulse shape while an
		    incorrect character exhibits a different current
		    pulse shape.</Example_Code>
		    <Body_Text>PIN numbers used to unlock a cell phone
		    should not exhibit any characteristics about
		    themselves. This creates a side channel. An
		    attacker could monitor the pulses using an
		    oscilloscope or other method. Once the first
		    character is correctly guessed (based on the
		    oscilloscope readings), they can then move to the
		    next character, which is much more efficient than
		    the brute force method of guessing every possible
		    sequence of characters.</Body_Text>
		    <Example_Code Nature="Good">Rather than comparing
		    each character to the correct PIN value as it is
		    entered, the device could accumulate the PIN in a
		    register, and do the comparison all at once at the
		    end. Alternatively, the components for the
		    comparison could be modified so that the current
		    pulse shape is the same regardless of the
		    correctness of the entered
		    character.</Example_Code>
		  </Demonstrative_Example>
		  <Demonstrative_Example>
			<Intro_Text>Consider the device vulnerability CVE-2021-3011, which affects certain microcontrollers [REF-1221]. The Google Titan Security Key is used for two-factor authentication using cryptographic algorithms. The device uses an internal secret key for this purpose and exchanges information based on this key for the authentication. If this internal secret key and the encryption algorithm were known to an adversary, the key function could be duplicated, allowing the adversary to masquerade as the legitimate user.</Intro_Text>
			<Example_Code Nature="Bad">The local method of extracting the secret key consists of plugging the key into a USB port and using electromagnetic (EM) sniffing tools and computers.</Example_Code>
			<Example_Code Nature="Good">Several solutions could have been considered by the manufacturer. For example, the manufacturer could shield the circuitry in the key or add randomized delays, indirect calculations with random values involved, or randomly ordered calculations to make extraction much more difficult or a combination of these techniques.</Example_Code>
		  </Demonstrative_Example>
		  <Demonstrative_Example>
		  	<Intro_Text>The code snippet provided here is part of the modular exponentiation module found in the HACK@DAC'21 Openpiton System-on-Chip (SoC), specifically within the RSA peripheral [REF-1368]. Modular exponentiation, denoted as "a^b mod n," is a crucial operation in the RSA public/private key encryption. In RSA encryption, where 'c' represents ciphertext, 'm' stands for a message, and 'd' corresponds to the private key, the decryption process is carried out using this modular exponentiation as follows: m = c^d mod n, where 'n' is the result of multiplying two large prime numbers.</Intro_Text>
		  	<Example_Code Nature="Bad" Language="Verilog">
				...<xhtml:br/>
				module mod_exp<xhtml:br/>
					<xhtml:div style="margin-left:1em;">
					...<xhtml:br/>
					`UPDATE: begin<xhtml:br/>
						<xhtml:div style="margin-left:1em;">
						if (exponent_reg != 'd0) begin<xhtml:br/>
							<xhtml:div style="margin-left:1em;">
							<xhtml:b>if (exponent_reg[0])</xhtml:b><xhtml:br/>
								<xhtml:div style="margin-left:1em;">
								<xhtml:b>result_reg &lt;= result_next;</xhtml:b><xhtml:br/>
								</xhtml:div>
							base_reg &lt;= base_next;<xhtml:br/>
							exponent_reg &lt;= exponent_next;<xhtml:br/>
							state &lt;= `UPDATE;<xhtml:br/>
							</xhtml:div>
						</xhtml:div>
					...<xhtml:br/>
					</xhtml:div>
				endmodule<xhtml:br/>
			</Example_Code>
		  	<Body_Text>The vulnerable code shows a buggy implementation of binary exponentiation where it updates the result register (result_reg) only when the corresponding exponent bit (exponent_reg[0]) is set to 1. However, when this exponent bit is 0, the output register is not updated. It's important to note that this implementation introduces a physical power side-channel vulnerability within the RSA core. This vulnerability could expose the private exponent to a determined physical attacker. Such exposure of the private exponent could lead to a complete compromise of the private key.</Body_Text>
			<Body_Text>To address mitigation requirements, the developer can develop the module by minimizing dependency on conditions, particularly those reliant on secret keys. In situations where branching is unavoidable, developers can implement masking mechanisms to obfuscate the power consumption patterns exhibited by the module (see good code example). Additionally, certain algorithms, such as the Karatsuba algorithm, can be implemented as illustrative examples of side-channel resistant algorithms, as they necessitate only a limited number of branch conditions [REF-1369].</Body_Text>
		  	<Example_Code Nature="Good" Language="Verilog">
			...<xhtml:br/>
				module mod_exp<xhtml:br/>
					<xhtml:div style="margin-left:1em;">
					...<xhtml:br/>
					`UPDATE: begin<xhtml:br/>
						<xhtml:div style="margin-left:1em;">
						if (exponent_reg != 'd0) begin<xhtml:br/>
							<xhtml:div style="margin-left:1em;">
							<xhtml:b>if (exponent_reg[0]) begin</xhtml:b><xhtml:br/>
								<xhtml:div style="margin-left:1em;">
								<xhtml:b>result_reg &lt;= result_next;</xhtml:b><xhtml:br/>
								</xhtml:div>
							<xhtml:b>end else begin</xhtml:b><xhtml:br/>
								<xhtml:div style="margin-left:1em;">
								<xhtml:b>mask_reg &lt;= result_next;</xhtml:b><xhtml:br/>
								</xhtml:div>
							<xhtml:b>end</xhtml:b><xhtml:br/>
							base_reg &lt;= base_next;<xhtml:br/>
							exponent_reg &lt;= exponent_next;<xhtml:br/>
							state &lt;= `UPDATE;<xhtml:br/>
							</xhtml:div>
						</xhtml:div>
					...<xhtml:br/>
					</xhtml:div>
				endmodule<xhtml:br/>
			</Example_Code>
		  </Demonstrative_Example>
		</Demonstrative_Examples>
		<Observed_Examples>
		  <Observed_Example>
		    <Reference>CVE-2022-35888</Reference>
		    <Description>Power side-channels leak secret information from processor</Description>
		    <Link>https://www.cve.org/CVERecord?id=CVE-2022-35888</Link>
		  </Observed_Example>
		  <Observed_Example>
		    <Reference>CVE-2021-3011</Reference>
		    <Description>electromagnetic-wave side-channel in security-related microcontrollers allows extraction of private key</Description>
		    <Link>https://www.cve.org/CVERecord?id=CVE-2021-3011</Link>
		  </Observed_Example>
		  <Observed_Example>
			<Reference>CVE-2019-14353</Reference>
			<Description>Crypto hardware wallet's power consumption relates to total number of pixels illuminated, creating a side channel in the USB connection that allows attackers to determine secrets displayed such as PIN numbers and passwords</Description>
			<Link>https://www.cve.org/CVERecord?id=CVE-2019-14353</Link>
		  </Observed_Example>
		  <Observed_Example>
		    <Reference>CVE-2020-27211</Reference>
		    <Description>Chain: microcontroller system-on-chip contains uses a register value stored in flash to set product protection state on the memory bus but does not contain protection against fault injection (CWE-1319), which leads to an incorrect initialization of the memory bus (CWE-1419) leading the product to be in an unprotected state.</Description>
		    <Link>https://www.cve.org/CVERecord?id=CVE-2020-27211</Link>
		  </Observed_Example>
		  <Observed_Example>
		    <Reference>CVE-2013-4576</Reference>
		    <Description>message encryption software uses certain instruction sequences that allows RSA key extraction using a chosen-ciphertext attack and acoustic cryptanalysis</Description>
		    <Link>https://www.cve.org/CVERecord?id=CVE-2013-4576</Link>
		  </Observed_Example>
		  <Observed_Example>
		    <Reference>CVE-2020-28368</Reference>
		    <Description>virtualization product allows recovery of AES keys from the guest OS using a side channel attack against a power/energy monitoring interface.</Description>
		    <Link>https://www.cve.org/CVERecord?id=CVE-2020-28368</Link>
		  </Observed_Example>
		  <Observed_Example>
		    <Reference>CVE-2019-18673</Reference>
		    <Description>power consumption varies based on number of pixels being illuminated in a display, allowing reading of secrets such as the PIN by using the USB interface to measure power consumption</Description>
		    <Link>https://www.cve.org/CVERecord?id=CVE-2019-18673</Link>
		  </Observed_Example>
		</Observed_Examples>
		<Functional_Areas>
            	  <Functional_Area>Power</Functional_Area>
         	</Functional_Areas>
         <Related_Attack_Patterns>
            <Related_Attack_Pattern CAPEC_ID="189"/>
            <Related_Attack_Pattern CAPEC_ID="699"/>
         </Related_Attack_Patterns>
         <References>
				<Reference External_Reference_ID="REF-1117"/>
				<Reference External_Reference_ID="REF-1118"/>
				<Reference External_Reference_ID="REF-1119"/>
				<Reference External_Reference_ID="REF-1120"/>
				<Reference External_Reference_ID="REF-1055"/>
				<Reference External_Reference_ID="REF-1218"/>
				<Reference External_Reference_ID="REF-1221"/>
				<Reference External_Reference_ID="REF-1228"/>
				<Reference External_Reference_ID="REF-1229"/>
				<Reference External_Reference_ID="REF-1230"/>
				<Reference External_Reference_ID="REF-1231" Section="pp. 305-319"/>
				<Reference External_Reference_ID="REF-1232" Section="pp. 123-130"/>
				<Reference External_Reference_ID="REF-1233"/>
				<Reference External_Reference_ID="REF-1234"/>
				<Reference External_Reference_ID="REF-1235"/>
				<Reference External_Reference_ID="REF-1239"/>
				<Reference External_Reference_ID="REF-1240"/>
				<Reference External_Reference_ID="REF-1285"/>
				<Reference External_Reference_ID="REF-1286" Section="1.2 / 5"/>
				<Reference External_Reference_ID="REF-1368"/>
				<Reference External_Reference_ID="REF-1369"/>
			</References>
         <Mapping_Notes>
            <Usage>Allowed</Usage>
            <Rationale>This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.</Rationale>
            <Comments>Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.</Comments>
            <Reasons>
               <Reason Type="Acceptable-Use"/>
            </Reasons>
         </Mapping_Notes>
			<Content_History>
				<Submission>
					<Submission_Name>Nicole Fern</Submission_Name>
					<Submission_Organization>Tortuga Logic</Submission_Organization>
					<Submission_Date>2020-05-29</Submission_Date>
					<Submission_Version>4.2</Submission_Version>
					<Submission_ReleaseDate>2020-08-20</Submission_ReleaseDate>
				</Submission>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-03-15</Modification_Date>
					<Modification_Comment>updated Functional_Areas, Maintenance_Notes</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-07-20</Modification_Date>
					<Modification_Comment>updated Related_Attack_Patterns</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2021-10-28</Modification_Date>
					<Modification_Comment>updated Demonstrative_Examples, Description, Detection_Factors, Maintenance_Notes, Name, Observed_Examples, References, Relationships, Weakness_Ordinalities</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2022-06-28</Modification_Date>
					<Modification_Comment>updated Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2022-10-13</Modification_Date>
					<Modification_Comment>updated References, Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-01-31</Modification_Date>
					<Modification_Comment>updated Related_Attack_Patterns</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-04-27</Modification_Date>
					<Modification_Comment>updated References, Relationships</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-06-29</Modification_Date>
					<Modification_Comment>updated Mapping_Notes</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-10-26</Modification_Date>
					<Modification_Comment>updated Demonstrative_Examples, Observed_Examples, References</Modification_Comment>
				</Modification>
				<Contribution Type="Content">
				  <Contribution_Name>Anders Nordstrom, Alric Althoff</Contribution_Name>
				  <Contribution_Organization>Tortuga Logic</Contribution_Organization>
				  <Contribution_Date>2021-10-11</Contribution_Date>
				  <Contribution_Comment>Provided detection methods, observed examples, and references</Contribution_Comment>
				</Contribution>
				<Contribution Type="Content">
				  <Contribution_Name>Nicole Fern</Contribution_Name>
				  <Contribution_Organization>Riscure</Contribution_Organization>
				  <Contribution_Date>2021-10-13</Contribution_Date>
				  <Contribution_Comment>Provided detection methods, observed examples, and references</Contribution_Comment>
				</Contribution>
				<Contribution Type="Content">
					<Contribution_Name>Chen Chen, Rahul Kande, Jeyavijayan Rajendran</Contribution_Name>
					<Contribution_Organization>Texas A&amp;M University</Contribution_Organization>
					<Contribution_Date>2023-06-21</Contribution_Date>
					<Contribution_Comment>suggested demonstrative example</Contribution_Comment>
				</Contribution>
				<Contribution Type="Content">
					<Contribution_Name>Shaza Zeitouni, Mohamadreza Rostami, Ahmad-Reza Sadeghi</Contribution_Name>
					<Contribution_Organization>Technical University of Darmstadt</Contribution_Organization>
					<Contribution_Date>2023-06-21</Contribution_Date>
					<Contribution_Comment>suggested demonstrative example</Contribution_Comment>
				</Contribution>
			<Previous_Entry_Name Date="2021-10-28">Improper Protection Against Physical Side Channels</Previous_Entry_Name>
			</Content_History>
		</Weakness>
   </Weaknesses>
   <Views>
      <View ID="1343" Name="Weaknesses in the 2021 CWE Most Important Hardware Weaknesses List" Type="Explicit" Status="Stable">
            <Objective>CWE entries in this view are listed in the 2021 CWE Most Important Hardware Weaknesses List, as determined by the Hardware CWE Special Interest Group (HW CWE SIG).</Objective>
            <Audience>
                <Stakeholder>
                    <Type>Hardware Designers</Type>
                    <Description>By following this list, hardware designers and implementers are able to significantly reduce the number of weaknesses that occur in their products.</Description>
                </Stakeholder>
                <Stakeholder>
               <Type>Product Customers</Type>
                    <Description>Customers can use the weaknesses in this view in order to formulate independent evidence of a claim by a product vendor to have eliminated / mitigated the most dangerous weaknesses.</Description>
                </Stakeholder>
                <Stakeholder>
                    <Type>Educators</Type>
                    <Description>Educators can use this view to focus curriculum on the most important hardware weaknesses.</Description>
                </Stakeholder>
            </Audience>
            <Members>
	      <Has_Member CWE_ID="1189" View_ID="1343"/>
	      <Has_Member CWE_ID="1191" View_ID="1343"/>
	      <Has_Member CWE_ID="1231" View_ID="1343"/>
	      <Has_Member CWE_ID="1233" View_ID="1343"/>
	      <Has_Member CWE_ID="1240" View_ID="1343"/>
	      <Has_Member CWE_ID="1244" View_ID="1343"/>
	      <Has_Member CWE_ID="1256" View_ID="1343"/>
	      <Has_Member CWE_ID="1260" View_ID="1343"/>
	      <Has_Member CWE_ID="1272" View_ID="1343"/>
	      <Has_Member CWE_ID="1274" View_ID="1343"/>
	      <Has_Member CWE_ID="1277" View_ID="1343"/>
	      <Has_Member CWE_ID="1300" View_ID="1343"/>
            </Members>
	    <References>
              <Reference External_Reference_ID="REF-1238"/>
	    </References>
         <Mapping_Notes>
            <Usage>Prohibited</Usage>
            <Rationale>This entry is a View. Views are not weaknesses and therefore inappropriate to describe the root causes of vulnerabilities.</Rationale>
            <Comments>Use this View or other Views to search and navigate for the appropriate weakness.</Comments>
            <Reasons>
               <Reason Type="View"/>
            </Reasons>
         </Mapping_Notes>
            <Content_History>
                <Submission>
                    <Submission_Name>CWE Content Team</Submission_Name>
                    <Submission_Organization>MITRE</Submission_Organization>
                    <Submission_Date>2021-09-29</Submission_Date>
                    <Submission_Version>4.6</Submission_Version>
                    <Submission_ReleaseDate>2021-10-28</Submission_ReleaseDate>
                </Submission>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2023-06-29</Modification_Date>
					<Modification_Comment>updated Mapping_Notes</Modification_Comment>
				</Modification>
            </Content_History>
        </View>
   </Views>
   <External_References>
      <External_Reference Reference_ID="REF-267">
			<Author>Information Technology Laboratory, National Institute of Standards and Technology</Author>
			<Title>SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES</Title>
			<Publication_Year>2001</Publication_Year>
			<Publication_Month>--05</Publication_Month>
			<Publication_Day>---25</Publication_Day>
			<URL>https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf</URL>
			<URL_Date>2023-04-07</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1036">
			<Author>Ali Abbasi and Majid Hashemi</Author>
			<Title>Ghost in the PLC Designing an Undetectable Programmable Logic Controller Rootkit via Pin Control Attack</Title>
			<Publication_Year>2016</Publication_Year>
			<URL>https://www.blackhat.com/docs/eu-16/materials/eu-16-Abbasi-Ghost-In-The-PLC-Designing-An-Undetectable-Programmable-Logic-Controller-Rootkit-wp.pdf</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1037">
			<Author>Kurt Rosenfeld</Author>
			<Author>Ramesh Karri</Author>
			<Title>Attacks and Defenses for JTAG</Title>
			<Publication_Year>2010</Publication_Year>
			<Publication_Month>--02</Publication_Month>
			<URL>https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5406671</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1043">
			<Author>Gopal Vishwakarma</Author>
			<Author>Wonjun Lee</Author>
			<Title>Exploiting JTAG and Its Mitigation in IOT: A Survey</Title>
			<Publication_Year>2018</Publication_Year>
			<Publication_Month>--12</Publication_Month>
			<Publication_Day>---03</Publication_Day>
			<URL>https://www.mdpi.com/1999-5903/10/12/121/pdf</URL>
			<URL_Date>2023-04-07</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1055">
			<Author>Peter Gutmann</Author>
			<Title>Data Remanence in Semiconductor Devices</Title>
			<Publication>10th USENIX Security Symposium</Publication>
			<Publication_Year>2001</Publication_Year>
			<Publication_Month>--08</Publication_Month>
			<URL>https://www.usenix.org/legacy/events/sec01/full_papers/gutmann/gutmann.pdf</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1056">
			<Author>F-Secure Labs</Author>
			<Title>Multiple Vulnerabilities in Barco Clickshare: JTAG access is not permanently disabled</Title>
			<URL>https://labs.f-secure.com/advisories/multiple-vulnerabilities-in-barco-clickshare/</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1057">
			<Author>Kurt Rosenfeld</Author>
			<Author>Ramesh Karri</Author>
			<Title>Attacks and Defenses for JTAG</Title>
			<URL>https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5406671</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1081">
			<Author>Kit Murdock</Author>
			<Author>David Oswald</Author>
			<Author>Flavio D Garcia</Author>
			<Author>Jo Van Bulck</Author>
			<Author>Frank Piessens</Author>
			<Author>Daniel Gruss</Author>
			<Title>Plundervolt</Title>
			<URL>https://plundervolt.com/</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1082">
			<Author>Adrian Tang</Author>
			<Author>Simha Sethumadhavan</Author>
			<Author>Salvatore Stolfo</Author>
			<Title>CLKSCREW: Exposing the Perils of Security-Oblivious Energy Management</Title>
			<URL>https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-tang.pdf</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1083">
			<Author>Yoongu Kim</Author>
			<Author>Ross Daly</Author>
			<Author>Jeremie Kim</Author>
			<Author>Ji Hye Lee</Author>
			<Author>Donghyuk Lee</Author>
			<Author>Chris Wilkerson</Author>
			<Author>Konrad Lai</Author>
			<Author>Onur Mutlu</Author>
			<Title>Flipping Bits in Memory Without Accessing Them: An Experimental Study of DRAM Disturbance Errors</Title>
			<URL>https://users.ece.cmu.edu/~yoonguk/papers/kim-isca14.pdf</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1084">
			<Author>Gopal Vishwakarma</Author>
			<Author>Wonjun Lee</Author>
			<Title>JTAG Explained (finally!): Why "IoT", Software Security Engineers, and Manufacturers Should Care</Title>
			<URL>https://www.mdpi.com/1999-5903/10/12/121/pdf</URL>
			<URL_Date>2023-04-07</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1085">
			<Author>Bob Molyneaux</Author>
			<Author>Mark McDermott</Author>
			<Author>Anil Sabbavarapu</Author>
			<Title>Design for Testability &amp; Design for Debug</Title>
			<URL>http://users.ece.utexas.edu/~mcdermot/vlsi-2/Lecture_17.pdf</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1095">
			<Author>Matthew Hughes</Author>
			<Title>Bad news: KeyWe Smart Lock is easily bypassed and can't be fixed</Title>
			<Publication_Year>2019</Publication_Year>
			<Publication_Month>--12</Publication_Month>
			<Publication_Day>---11</Publication_Day>
			<URL>https://www.theregister.com/2019/12/11/f_secure_keywe/</URL>
			<URL_Date>2023-04-07</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1096">
			<Author>Alex Scroxton</Author>
			<Title>Alarm bells ring, the IoT is listening</Title>
			<URL>https://www.computerweekly.com/news/252475324/Alarm-bells-ring-the-IoT-is-listening</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1097">
			<Author>Brian Krebs</Author>
			<Title>Zyxel Flaw Powers New Mirai IoT Botnet Strain</Title>
			<Publication_Year>2020</Publication_Year>
			<Publication_Month>--03</Publication_Month>
			<Publication_Day>---20</Publication_Day>
			<URL>https://krebsonsecurity.com/2020/03/zxyel-flaw-powers-new-mirai-iot-botnet-strain/</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1100">
			<Author>Christopher Domas</Author>
			<Title>The Memory Sinkhole</Title>
			<Publication_Year>2015</Publication_Year>
			<Publication_Month>--07</Publication_Month>
			<Publication_Day>---20</Publication_Day>
			<URL>https://github.com/xoreaxeaxeax/sinkhole/blob/master/us-15-Domas-TheMemorySinkhole-wp.pdf</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1117">
			<Author>Paul Kocher</Author>
			<Author>Joshua Jaffe</Author>
			<Author>Benjamin Jun</Author>
			<Title>Introduction to differential power analysis and related attacks</Title>
			<Publication_Year>1998</Publication_Year>
			<URL>https://www.rambus.com/wp-content/uploads/2015/08/DPATechInfo.pdf</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1118">
			<Author>Dakshi Agrawal</Author>
			<Author>Bruce Archambeault</Author>
			<Author>Josyula R. Rao</Author>
			<Author>Pankaj Rohatgi</Author>
			<Title>The EM Side-Channel(s)</Title>
			<Publication_Year>2007</Publication_Year>
			<Publication_Month>--08</Publication_Month>
			<Publication_Day>---24</Publication_Day>
			<URL>https://link.springer.com/content/pdf/10.1007/3-540-36400-5_4.pdf</URL>
			<URL_Date>2023-04-07</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1119">
			<Author>Daniel Genkin</Author>
			<Author>Adi Shamir</Author>
			<Author>Eran Tromer</Author>
			<Title>RSA key extraction via low-bandwidth acoustic cryptanalysis</Title>
			<Publication_Year>2014</Publication_Year>
			<Publication_Month>--06</Publication_Month>
			<Publication_Day>---13</Publication_Day>
			<URL>https://www.iacr.org/archive/crypto2014/86160149/86160149.pdf</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1120">
			<Author>Colin O'Flynn</Author>
			<Title>Power Analysis for Cheapskates</Title>
			<Publication_Year>2013</Publication_Year>
			<Publication_Month>--01</Publication_Month>
			<Publication_Day>---24</Publication_Day>
			<URL>https://media.blackhat.com/eu-13/briefings/OFlynn/bh-eu-13-for-cheapstakes-oflynn-wp.pdf</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1138">
			<Author>Stewart Smith</Author>
			<Title>CVE-2019-6260: Gaining control of BMC from the host processor</Title>
			<Publication_Year>2019</Publication_Year>
			<URL>https://www.flamingspork.com/blog/2019/01/23/cve-2019-6260:-gaining-control-of-bmc-from-the-host-processor/</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1192">
			<Author>Information Technology Laboratory, National Institute of Standards and Technology</Author>
			<Title>FIPS PUB 140-3: SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES</Title>
			<Publication_Year>2019</Publication_Year>
			<Publication_Month>--03</Publication_Month>
			<Publication_Day>---22</Publication_Day>
			<URL>https://csrc.nist.gov/publications/detail/fips/140/3/final</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1217">
			<Author>Ross Anderson</Author>
			<Title>Security Engineering</Title>
			<Publication_Year>2001</Publication_Year>
			<URL>https://www.cl.cam.ac.uk/~rja14/musicfiles/manuscripts/SEv1.pdf</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1218">
			<Author>Graham Cluley</Author>
			<Title>This Black Box Can Brute Force Crack iPhone PIN Passcodes</Title>
			<Publication>The Mac Security Blog</Publication>
			<Publication_Year>2015</Publication_Year>
			<Publication_Month>--03</Publication_Month>
			<Publication_Day>---16</Publication_Day>
			<URL>https://www.intego.com/mac-security-blog/iphone-pin-pass-code/</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1219">
			<Author>Monodeep Kar</Author>
			<Author>Arvind Singh</Author>
			<Author>Santosh Ghosh</Author>
			<Author>Sanu Mathew</Author>
			<Author>Anand Rajan</Author>
			<Author>Vivek De</Author>
			<Author>Raheem Beyah</Author>
			<Author>Saibal Mukhopadhyay</Author>
			<Title>Blindsight: Blinding EM Side-Channel Leakage using Built-In Fully Integrated Inductive Voltage Regulator</Title>
			<Publication_Year>2018</Publication_Year>
			<Publication_Month>--02</Publication_Month>
			<URL>https://arxiv.org/pdf/1802.09096.pdf</URL>
			<URL_Date>2023-04-07</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1220">
			<Author>Zhenyu Ning</Author>
			<Author>Fengwei Zhang</Author>
			<Title>Understanding the Security of ARM Debugging Features</Title>
			<Publication>2019 IEEE Symposium on Security and Privacy (SP)</Publication>
			<Publication_Year>2019</Publication_Year>
			<Publication_Month>--05</Publication_Month>
			<Publication_Day>---22</Publication_Day>
			<URL>https://www.computer.org/csdl/proceedings-article/sp/2019/666000b156/19skgcwSgsE</URL>
			<URL_Date>2023-04-07</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1221">
			<Author>Victor Lomne</Author>
			<Author>Thomas Roche</Author>
			<Title>A Side Journey to Titan</Title>
			<Publication_Year>2021</Publication_Year>
			<Publication_Month>--01</Publication_Month>
			<Publication_Day>---07</Publication_Day>
			<URL>https://web.archive.org/web/20210107182441/https://ninjalab.io/wp-content/uploads/2021/01/a_side_journey_to_titan.pdf</URL>
			<URL_Date>2023-04-07</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1225">
			<Author>Project Zero</Author>
			<Title>Exploiting the DRAM rowhammer bug to gain kernel privileges</Title>
			<Publication_Year>2015</Publication_Year>
			<Publication_Month>--03</Publication_Month>
			<Publication_Day>---09</Publication_Day>
			<URL>https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1226">
			<Author>Information Technology Laboratory, National Institute of Standards and Technology</Author>
			<Title>FIPS PUB 140-2: SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES</Title>
			<Publication_Year>2001</Publication_Year>
			<Publication_Month>--05</Publication_Month>
			<Publication_Day>---25</Publication_Day>
			<URL>https://csrc.nist.gov/publications/detail/fips/140/2/final</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1227">
			<Author>Wikipedia</Author>
			<Title>Cryptographic primitive</Title>
			<URL>https://en.wikipedia.org/wiki/Cryptographic_primitive</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1228">
			<Author>Gilbert Goodwill</Author>
			<Author>Benjamin Jun</Author>
			<Author>Josh Jaffe</Author>
			<Author>Pankaj Rohatgi</Author>
			<Title>A testing methodology for side-channel resistance validation</Title>
			<Publication_Year>2011</Publication_Year>
			<URL>https://csrc.nist.gov/csrc/media/events/non-invasive-attack-testing-workshop/documents/08_goodwill.pdf</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1229">
			<Author>ISO/IEC</Author>
			<Title>ISO/IEC 17825:2016: Testing methods for the mitigation of non-invasive attack classes against cryptographic modules</Title>
			<Publication_Year>2016</Publication_Year>
			<URL>https://www.iso.org/standard/60612.html</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1230">
			<Author>Cryptography Research Inc.</Author>
			<Title>Test Vector Leakage Assessment (TVLA) Derived Test Requirements (DTR) with AES</Title>
			<Publication_Year>2015</Publication_Year>
			<Publication_Month>--08</Publication_Month>
			<URL>https://www.rambus.com/wp-content/uploads/2015/08/TVLA-DTR-with-AES.pdf</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1231">
			<Author>Danilo ijaci</Author>
			<Author>Josep Balasch</Author>
			<Author>Bohan Yang</Author>
			<Author>Santosh Ghosh</Author>
			<Author>Ingrid Verbauwhede</Author>
			<Title>Towards efficient and automated side-channel evaluations at design time</Title>
			<Publication>Journal of Cryptographic Engineering, 10(4)</Publication>
			<Publication_Year>2020</Publication_Year>
			<URL>https://www.esat.kuleuven.be/cosic/publications/article-3204.pdf</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1232">
			<Author>Amit Kumar</Author>
			<Author>Cody Scarborough</Author>
			<Author>Ali Yilmaz</Author>
			<Author>Michael Orshansky</Author>
			<Title>Efficient simulation of EM side-channel attack resilience</Title>
			<Publication>IEEE/ACM International Conference on Computer-Aided Design (ICCAD)</Publication>
			<Publication_Year>2017</Publication_Year>
			<URL>https://dl.acm.org/doi/pdf/10.5555/3199700.3199717</URL>
			<URL_Date>2023-04-07</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1233">
			<Author>Yuan Yao</Author>
			<Author>Tuna Tufan</Author>
			<Author>Tarun Kathuria</Author>
			<Author>Baris Ege</Author>
			<Author>Ulkuhan Guler</Author>
			<Author>Patrick Schaumont</Author>
			<Title>Pre-silicon Architecture Correlation Analysis (PACA): Identifying and Mitigating the Source of Side-channel Leakage at Gate-level</Title>
			<Publication_Year>2021</Publication_Year>
			<Publication_Month>--04</Publication_Month>
			<Publication_Day>---21</Publication_Day>
			<Publisher>IACR Cryptology ePrint Archive</Publisher>
			<URL>https://eprint.iacr.org/2021/530.pdf</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1234">
			<Author>Elisabeth Oswald</Author>
			<Author>Thomas Popp</Author>
			<Author>Stefan Mangard</Author>
			<Title>Power Analysis Attacks - Revealing the Secrets of Smart Cards</Title>
			<Publication_Year>2007</Publication_Year>
			<URL>https://link.springer.com/book/10.1007/978-0-387-38162-6</URL>
			<URL_Date>2023-04-07</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1235">
			<Author>David Oswald</Author>
			<Author>Bastian Richter</Author>
			<Author>Christof Paar</Author>
			<Title>Side-Channel Attacks on the Yubikey 2 One-Time Password Generator</Title>
			<Publication_Year>2013</Publication_Year>
			<Publication_Month>--06</Publication_Month>
			<Publication_Day>---14</Publication_Day>
			<URL>https://www.emsec.ruhr-uni-bochum.de/media/crypto/veroeffentlichungen/2014/02/04/paper_yubikey_sca.pdf</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1236">
			<Author>NIST</Author>
			<Title>CAVP Testing: Individual Component Testing</Title>
			<URL>https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program/component-testing</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1237">
			<Author>CERT Coordination Center</Author>
			<Title>Intel BIOS locking mechanism contains race condition that enables write protection bypass</Title>
			<Publication_Year>2015</Publication_Year>
			<Publication_Month>--01</Publication_Month>
			<Publication_Day>---05</Publication_Day>
			<URL>https://www.kb.cert.org/vuls/id/766164/</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1238">
			<Author>MITRE</Author>
			<Title>2021 CWE Most Important Hardware Weaknesses</Title>
			<Publication_Year>2021</Publication_Year>
			<Publication_Month>--10</Publication_Month>
			<Publication_Day>---28</Publication_Day>
			<URL>https://cwe.mitre.org/scoring/lists/2021_CWE_MiHW.html</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1239">
			<Author>Franois-Xavier Standaert</Author>
			<Title>How (not) to Use Welch's T-test in Side-Channel Security Evaluations</Title>
			<Publication_Year>2017</Publication_Year>
			<Publication_Month>--02</Publication_Month>
			<Publication_Day>---15</Publication_Day>
			<Publisher>IACR Cryptology ePrint Archive</Publisher>
			<URL>https://eprint.iacr.org/2017/138.pdf</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1240">
			<Author>Carolyn Whitnall</Author>
			<Author>Elisabeth Oswald</Author>
			<Title>A Critical Analysis of ISO 17825 ('Testing methods for the mitigation of non-invasive attack classes against cryptographic modules')</Title>
			<Publication_Year>2019</Publication_Year>
			<Publication_Month>--09</Publication_Month>
			<Publication_Day>---10</Publication_Day>
			<Publisher>IACR Cryptology ePrint Archive</Publisher>
			<URL>https://eprint.iacr.org/2019/1013.pdf</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1285">
			<Author>Texas Instruments</Author>
			<Title>Physical Security Attacks Against Silicon Devices</Title>
			<Publication_Year>2022</Publication_Year>
			<Publication_Month>--01</Publication_Month>
			<Publication_Day>---31</Publication_Day>
			<URL>https://www.ti.com/lit/an/swra739/swra739.pdf?ts=1644234570420</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1286">
			<Author>Lennert Wouters</Author>
			<Author>Benedikt Gierlichs</Author>
			<Author>Bart Preneel</Author>
			<Title>On The Susceptibility of Texas Instruments SimpleLink Platform Microcontrollers to Non-Invasive Physical Attacks</Title>
			<Publication_Year>2022</Publication_Year>
			<Publication_Month>--03</Publication_Month>
			<Publication_Day>---14</Publication_Day>
			<URL>https://eprint.iacr.org/2022/328.pdf</URL>
		</External_Reference>
      <External_Reference Reference_ID="REF-1338">
			<Title>Hackatdac19 ariane_soc_pkg.sv</Title>
			<Publication_Year>2019</Publication_Year>
			<URL>https://github.com/HACK-EVENT/hackatdac19/blob/619e9fb0ef32ee1e01ad76b8732a156572c65700/tb/ariane_soc_pkg.sv#L44:L62</URL>
			<URL_Date>2023-06-21</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1339">
			<Author>Florian Zaruba</Author>
			<Author>Michael Schaffner</Author>
			<Author>Andreas Traber</Author>
			<Title>csr_regfile.sv</Title>
			<Publication_Year>2019</Publication_Year>
			<URL>https://github.com/openhwgroup/cva6/blob/7951802a0147aedb21e8f2f6dc1e1e9c4ee857a2/src/csr_regfile.sv#L45</URL>
			<URL_Date>2023-06-21</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1350">
			<Title>reglk_wrapper.sv</Title>
			<Publication_Year>2021</Publication_Year>
			<URL>https://github.com/HACK-EVENT/hackatdac21/blob/b9ecdf6068445d76d6bee692d163fededf7a9d9b/piton/design/chip/tile/ariane/src/reglk/reglk_wrapper.sv#L80C1-L80C48</URL>
			<URL_Date>2023-09-18</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1351">
			<Title>fix cwe 1199 in reglk</Title>
			<Publication_Year>2023</Publication_Year>
			<URL>https://github.com/HACK-EVENT/hackatdac21/commit/5928add42895b57341ae8fc1f9b8351c35aed865#diff-1c2b09dd092a56e5fb2be431a3849e72ff489d2ae4f4a6bb9c0ea6b7d450135aR80</URL>
			<URL_Date>2023-09-18</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1352">
			<Author>Florian Zaruba</Author>
			<Title>dmi_jtag.sv</Title>
			<Publication_Year>2021</Publication_Year>
			<URL>https://github.com/HACK-EVENT/hackatdac21/blob/71103971e8204de6a61afc17d3653292517d32bf/piton/design/chip/tile/ariane/src/riscv-dbg/src/dmi_jtag.sv#L118:L204</URL>
			<URL_Date>2023-09-18</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1353">
			<Author>Florian Zaruba</Author>
			<Title>Fix CWE-1191 in dmi_jtag.sv</Title>
			<Publication_Year>2021</Publication_Year>
			<URL>https://github.com/HACK-EVENT/hackatdac21/blob/58f984d492fdb0369c82ef10fcbbaa4b9850f9fb/piton/design/chip/tile/ariane/src/riscv-dbg/src/dmi_jtag.sv#L131</URL>
			<URL_Date>2023-09-18</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1354">
			<Author>Florian Zaruba</Author>
			<Title>Fix CWE-1191 in dmi_jtag.sv</Title>
			<Publication_Year>2021</Publication_Year>
			<URL>https://github.com/HACK-EVENT/hackatdac21/blob/58f984d492fdb0369c82ef10fcbbaa4b9850f9fb/piton/design/chip/tile/ariane/src/riscv-dbg/src/dmi_jtag.sv#L200</URL>
			<URL_Date>2023-09-18</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1355">
			<Author>Florian Zaruba</Author>
			<Title>dmi_jtag.sv</Title>
			<Publication_Year>2021</Publication_Year>
			<URL>https://github.com/HACK-EVENT/hackatdac21/blob/71103971e8204de6a61afc17d3653292517d32bf/piton/design/chip/tile/ariane/src/riscv-dbg/src/dmi_jtag.sv#L192:L204</URL>
			<URL_Date>2023-09-18</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1364">
			<Title>dmi_jtag.sv</Title>
			<Publication_Year>2021</Publication_Year>
			<URL>https://github.com/HACK-EVENT/hackatdac21/blob/71103971e8204de6a61afc17d3653292517d32bf/piton/design/chip/tile/ariane/src/riscv-dbg/src/dmi_jtag.sv#L82</URL>
			<URL_Date>2023-07-15</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1365">
			<Title>fix cwe_1205 in dmi_jtag.sv</Title>
			<Publication_Year>2021</Publication_Year>
			<URL>https://github.com/HACK-EVENT/hackatdac21/blob/c4f4b832218b50c406dbf9f425d3b654117c1355/piton/design/chip/tile/ariane/src/riscv-dbg/src/dmi_jtag.sv#L158</URL>
			<URL_Date>2023-07-22</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1368">
			<Title>mod_exp.v</Title>
			<Publication_Year>2021</Publication_Year>
			<URL>https://github.com/HACK-EVENT/hackatdac21/blob/b9ecdf6068445d76d6bee692d163fededf7a9d9b/piton/design/chip/tile/ariane/src/rsa/mod_exp.v#L46:L47</URL>
			<URL_Date>2023-07-15</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1369">
			<Title>Fix CWE-1300</Title>
			<Publication_Year>2021</Publication_Year>
			<URL>https://github.com/HACK-EVENT/hackatdac21/blob/37e42f724c14b8e4cc8f6e13462c12a492778219/piton/design/chip/tile/ariane/src/rsa/mod_exp.v#L47:L51</URL>
			<URL_Date>2023-09-29</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1377">
			<Title>csr_regile.sv line 938</Title>
			<Publication_Year>2021</Publication_Year>
			<URL>https://github.com/HACK-EVENT/hackatdac19/blob/57e7b2109c1ea2451914878df2e6ca740c2dcf34/src/csr_regfile.sv#L938</URL>
			<URL_Date>2023-12-13</URL_Date>
		</External_Reference>
      <External_Reference Reference_ID="REF-1378">
			<Title>Fix for csr_regfile.sv line 938</Title>
			<Publication_Year>2021</Publication_Year>
			<URL>https://github.com/HACK-EVENT/hackatdac19/blob/a7b61209e56c48eec585eeedea8413997ec71e4a/src/csr_regfile.sv#L938C31-L938C56</URL>
			<URL_Date>2023-12-13</URL_Date>
		</External_Reference>
   </External_References>
</Weakness_Catalog>