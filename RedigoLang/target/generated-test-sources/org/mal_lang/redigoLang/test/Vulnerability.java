package org.mal_lang.redigoLang.test;

import core.Asset;
import core.AttackStep;
import core.AttackStepMax;
import core.AttackStepMin;
import core.Defense;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.util.HashSet;
import java.util.Set;

public abstract class Vulnerability extends Asset {
  public NotPresent notPresent;

  public AttemptAbuse attemptAbuse;

  public Abuse abuse;

  public AttemptExploit attemptExploit;

  public Exploit exploit;

  public Impact impact;

  public Vulnerability(String name, boolean isNotPresentEnabled) {
    super(name);
    assetClassName = "Vulnerability";
    if (notPresent != null) {
      AttackStep.allAttackSteps.remove(notPresent.disable);
    }
    Defense.allDefenses.remove(notPresent);
    notPresent = new NotPresent(name, isNotPresentEnabled);
    AttackStep.allAttackSteps.remove(attemptAbuse);
    attemptAbuse = new AttemptAbuse(name);
    AttackStep.allAttackSteps.remove(abuse);
    abuse = new Abuse(name);
    AttackStep.allAttackSteps.remove(attemptExploit);
    attemptExploit = new AttemptExploit(name);
    AttackStep.allAttackSteps.remove(exploit);
    exploit = new Exploit(name);
    AttackStep.allAttackSteps.remove(impact);
    impact = new Impact(name);
  }

  public Vulnerability(String name) {
    super(name);
    assetClassName = "Vulnerability";
    if (notPresent != null) {
      AttackStep.allAttackSteps.remove(notPresent.disable);
    }
    Defense.allDefenses.remove(notPresent);
    notPresent = new NotPresent(name, false);
    AttackStep.allAttackSteps.remove(attemptAbuse);
    attemptAbuse = new AttemptAbuse(name);
    AttackStep.allAttackSteps.remove(abuse);
    abuse = new Abuse(name);
    AttackStep.allAttackSteps.remove(attemptExploit);
    attemptExploit = new AttemptExploit(name);
    AttackStep.allAttackSteps.remove(exploit);
    exploit = new Exploit(name);
    AttackStep.allAttackSteps.remove(impact);
    impact = new Impact(name);
  }

  public Vulnerability(boolean isNotPresentEnabled) {
    this("Anonymous", isNotPresentEnabled);
  }

  public Vulnerability() {
    this("Anonymous");
  }

  public class NotPresent extends Defense {
    public NotPresent(String name) {
      this(name, false);
    }

    public NotPresent(String name, Boolean isEnabled) {
      super(name);
      defaultValue = isEnabled;
      disable = new Disable(name);
    }

    public class Disable extends AttackStepMin {
      private Set<AttackStep> _cacheChildrenNotPresent;

      public Disable(String name) {
        super(name);
      }

      @Override
      public void updateChildren(Set<AttackStep> attackSteps) {
        if (_cacheChildrenNotPresent == null) {
          _cacheChildrenNotPresent = new HashSet<>();
          _cacheChildrenNotPresent.add(abuse);
        }
        for (AttackStep attackStep : _cacheChildrenNotPresent) {
          attackStep.updateTtc(this, ttc, attackSteps);
        }
      }

      @Override
      public String fullName() {
        return "Vulnerability.notPresent";
      }
    }
  }

  public class AttemptAbuse extends AttackStepMin {
    private Set<AttackStep> _cacheChildrenAttemptAbuse;

    private Set<AttackStep> _cacheParentAttemptAbuse;

    public AttemptAbuse(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenAttemptAbuse == null) {
        _cacheChildrenAttemptAbuse = new HashSet<>();
        _cacheChildrenAttemptAbuse.add(abuse);
      }
      for (AttackStep attackStep : _cacheChildrenAttemptAbuse) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentAttemptAbuse == null) {
        _cacheParentAttemptAbuse = new HashSet<>();
        if (Vulnerability.this instanceof HardwareVulnerability) {
          if (((org.mal_lang.redigoLang.test.HardwareVulnerability) Vulnerability.this).hardware != null) {
            _cacheParentAttemptAbuse.add(((org.mal_lang.redigoLang.test.HardwareVulnerability) Vulnerability.this).hardware.useVulnerability);
          }
        }
      }
      for (AttackStep attackStep : _cacheParentAttemptAbuse) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("Vulnerability.attemptAbuse");
    }
  }

  public class Abuse extends AttackStepMax {
    private Set<AttackStep> _cacheChildrenAbuse;

    private Set<AttackStep> _cacheParentAbuse;

    public Abuse(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenAbuse == null) {
        _cacheChildrenAbuse = new HashSet<>();
        _cacheChildrenAbuse.add(attemptExploit);
      }
      for (AttackStep attackStep : _cacheChildrenAbuse) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentAbuse == null) {
        _cacheParentAbuse = new HashSet<>();
        _cacheParentAbuse.add(notPresent.disable);
        _cacheParentAbuse.add(attemptAbuse);
        if (Vulnerability.this instanceof SoftwareVulnerability) {
          _cacheParentAbuse.add(((org.mal_lang.redigoLang.test.SoftwareVulnerability) Vulnerability.this).networkAccessAchieved);
        }
        if (Vulnerability.this instanceof SoftwareVulnerability) {
          _cacheParentAbuse.add(((org.mal_lang.redigoLang.test.SoftwareVulnerability) Vulnerability.this).localAccessAchieved);
        }
        if (Vulnerability.this instanceof SoftwareVulnerability) {
          _cacheParentAbuse.add(((org.mal_lang.redigoLang.test.SoftwareVulnerability) Vulnerability.this).physicalAccessAchieved);
        }
        if (Vulnerability.this instanceof SoftwareVulnerability) {
          _cacheParentAbuse.add(((org.mal_lang.redigoLang.test.SoftwareVulnerability) Vulnerability.this).lowPrivilegesAchieved);
        }
        if (Vulnerability.this instanceof SoftwareVulnerability) {
          _cacheParentAbuse.add(((org.mal_lang.redigoLang.test.SoftwareVulnerability) Vulnerability.this).highPrivilegesAchieved);
        }
        if (Vulnerability.this instanceof SoftwareVulnerability) {
          _cacheParentAbuse.add(((org.mal_lang.redigoLang.test.SoftwareVulnerability) Vulnerability.this).userInteractionAchieved);
        }
        if (Vulnerability.this instanceof HardwareVulnerability) {
          _cacheParentAbuse.add(((org.mal_lang.redigoLang.test.HardwareVulnerability) Vulnerability.this).physicalAccessAchieved);
        }
      }
      for (AttackStep attackStep : _cacheParentAbuse) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("Vulnerability.abuse");
    }
  }

  public class AttemptExploit extends AttackStepMin {
    private Set<AttackStep> _cacheChildrenAttemptExploit;

    private Set<AttackStep> _cacheParentAttemptExploit;

    public AttemptExploit(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenAttemptExploit == null) {
        _cacheChildrenAttemptExploit = new HashSet<>();
        _cacheChildrenAttemptExploit.add(exploit);
      }
      for (AttackStep attackStep : _cacheChildrenAttemptExploit) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentAttemptExploit == null) {
        _cacheParentAttemptExploit = new HashSet<>();
        _cacheParentAttemptExploit.add(abuse);
      }
      for (AttackStep attackStep : _cacheParentAttemptExploit) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("Vulnerability.attemptExploit");
    }
  }

  public class Exploit extends AttackStepMin {
    private Set<AttackStep> _cacheChildrenExploit;

    private Set<AttackStep> _cacheParentExploit;

    public Exploit(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenExploit == null) {
        _cacheChildrenExploit = new HashSet<>();
        _cacheChildrenExploit.add(impact);
      }
      for (AttackStep attackStep : _cacheChildrenExploit) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentExploit == null) {
        _cacheParentExploit = new HashSet<>();
        _cacheParentExploit.add(attemptExploit);
        if (Vulnerability.this instanceof SoftwareVulnerability) {
          _cacheParentExploit.add(((org.mal_lang.redigoLang.test.SoftwareVulnerability) Vulnerability.this).exploitTrivially);
        }
        if (Vulnerability.this instanceof SoftwareVulnerability) {
          _cacheParentExploit.add(((org.mal_lang.redigoLang.test.SoftwareVulnerability) Vulnerability.this).exploitWithEffort);
        }
        if (Vulnerability.this instanceof HardwareVulnerability) {
          _cacheParentExploit.add(((org.mal_lang.redigoLang.test.HardwareVulnerability) Vulnerability.this).exploitTrivially);
        }
        if (Vulnerability.this instanceof HardwareVulnerability) {
          _cacheParentExploit.add(((org.mal_lang.redigoLang.test.HardwareVulnerability) Vulnerability.this).exploitWithEffort);
        }
      }
      for (AttackStep attackStep : _cacheParentExploit) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("Vulnerability.exploit");
    }
  }

  public class Impact extends AttackStepMin {
    private Set<AttackStep> _cacheParentImpact;

    public Impact(String name) {
      super(name);
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentImpact == null) {
        _cacheParentImpact = new HashSet<>();
        _cacheParentImpact.add(exploit);
      }
      for (AttackStep attackStep : _cacheParentImpact) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("Vulnerability.impact");
    }
  }
}
