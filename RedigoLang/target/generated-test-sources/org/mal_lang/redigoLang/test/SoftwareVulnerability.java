package org.mal_lang.redigoLang.test;

import core.Asset;
import core.AttackStep;
import core.AttackStepMax;
import core.AttackStepMin;
import core.Defense;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.util.HashSet;
import java.util.Set;

public class SoftwareVulnerability extends Vulnerability {
  public NetworkAccessRequired networkAccessRequired;

  public LocalAccessRequired localAccessRequired;

  public PhysicalAccessRequired physicalAccessRequired;

  public LowPrivilegesRequired lowPrivilegesRequired;

  public HighPrivilegesRequired highPrivilegesRequired;

  public UserInteractionRequired userInteractionRequired;

  public ConfidentialityImpactLimitations confidentialityImpactLimitations;

  public AvailabilityImpactLimitations availabilityImpactLimitations;

  public IntegrityImpactLimitations integrityImpactLimitations;

  public HighComplexityExploitRequired highComplexityExploitRequired;

  public InherentUserInteraction inherentUserInteraction;

  public NetworkAccessAchieved networkAccessAchieved;

  public LocalAccessAchieved localAccessAchieved;

  public PhysicalAccessAchieved physicalAccessAchieved;

  public LowPrivilegesAchieved lowPrivilegesAchieved;

  public HighPrivilegesAchieved highPrivilegesAchieved;

  public UserInteractionAchieved userInteractionAchieved;

  public Read read;

  public Modify modify;

  public Deny deny;

  public ExploitTrivially exploitTrivially;

  public ExploitWithEffort exploitWithEffort;

  private Set<Application> _cachereverseallVulnerabilitiesApplication;

  public Application application = null;

  public SoftwareProduct softwareProduct = null;

  public SoftwareVulnerability(String name, boolean isNotPresentEnabled,
      boolean isNetworkAccessRequiredEnabled, boolean isLocalAccessRequiredEnabled,
      boolean isPhysicalAccessRequiredEnabled, boolean isLowPrivilegesRequiredEnabled,
      boolean isHighPrivilegesRequiredEnabled, boolean isUserInteractionRequiredEnabled,
      boolean isConfidentialityImpactLimitationsEnabled,
      boolean isAvailabilityImpactLimitationsEnabled, boolean isIntegrityImpactLimitationsEnabled,
      boolean isHighComplexityExploitRequiredEnabled) {
    super(name, isNotPresentEnabled);
    assetClassName = "SoftwareVulnerability";
    if (networkAccessRequired != null) {
      AttackStep.allAttackSteps.remove(networkAccessRequired.disable);
    }
    Defense.allDefenses.remove(networkAccessRequired);
    networkAccessRequired = new NetworkAccessRequired(name, isNetworkAccessRequiredEnabled);
    if (localAccessRequired != null) {
      AttackStep.allAttackSteps.remove(localAccessRequired.disable);
    }
    Defense.allDefenses.remove(localAccessRequired);
    localAccessRequired = new LocalAccessRequired(name, isLocalAccessRequiredEnabled);
    if (physicalAccessRequired != null) {
      AttackStep.allAttackSteps.remove(physicalAccessRequired.disable);
    }
    Defense.allDefenses.remove(physicalAccessRequired);
    physicalAccessRequired = new PhysicalAccessRequired(name, isPhysicalAccessRequiredEnabled);
    if (lowPrivilegesRequired != null) {
      AttackStep.allAttackSteps.remove(lowPrivilegesRequired.disable);
    }
    Defense.allDefenses.remove(lowPrivilegesRequired);
    lowPrivilegesRequired = new LowPrivilegesRequired(name, isLowPrivilegesRequiredEnabled);
    if (highPrivilegesRequired != null) {
      AttackStep.allAttackSteps.remove(highPrivilegesRequired.disable);
    }
    Defense.allDefenses.remove(highPrivilegesRequired);
    highPrivilegesRequired = new HighPrivilegesRequired(name, isHighPrivilegesRequiredEnabled);
    if (userInteractionRequired != null) {
      AttackStep.allAttackSteps.remove(userInteractionRequired.disable);
    }
    Defense.allDefenses.remove(userInteractionRequired);
    userInteractionRequired = new UserInteractionRequired(name, isUserInteractionRequiredEnabled);
    if (confidentialityImpactLimitations != null) {
      AttackStep.allAttackSteps.remove(confidentialityImpactLimitations.disable);
    }
    Defense.allDefenses.remove(confidentialityImpactLimitations);
    confidentialityImpactLimitations = new ConfidentialityImpactLimitations(name, isConfidentialityImpactLimitationsEnabled);
    if (availabilityImpactLimitations != null) {
      AttackStep.allAttackSteps.remove(availabilityImpactLimitations.disable);
    }
    Defense.allDefenses.remove(availabilityImpactLimitations);
    availabilityImpactLimitations = new AvailabilityImpactLimitations(name, isAvailabilityImpactLimitationsEnabled);
    if (integrityImpactLimitations != null) {
      AttackStep.allAttackSteps.remove(integrityImpactLimitations.disable);
    }
    Defense.allDefenses.remove(integrityImpactLimitations);
    integrityImpactLimitations = new IntegrityImpactLimitations(name, isIntegrityImpactLimitationsEnabled);
    if (highComplexityExploitRequired != null) {
      AttackStep.allAttackSteps.remove(highComplexityExploitRequired.disable);
    }
    Defense.allDefenses.remove(highComplexityExploitRequired);
    highComplexityExploitRequired = new HighComplexityExploitRequired(name, isHighComplexityExploitRequiredEnabled);
    AttackStep.allAttackSteps.remove(inherentUserInteraction);
    inherentUserInteraction = new InherentUserInteraction(name);
    AttackStep.allAttackSteps.remove(networkAccessAchieved);
    networkAccessAchieved = new NetworkAccessAchieved(name);
    AttackStep.allAttackSteps.remove(localAccessAchieved);
    localAccessAchieved = new LocalAccessAchieved(name);
    AttackStep.allAttackSteps.remove(physicalAccessAchieved);
    physicalAccessAchieved = new PhysicalAccessAchieved(name);
    AttackStep.allAttackSteps.remove(lowPrivilegesAchieved);
    lowPrivilegesAchieved = new LowPrivilegesAchieved(name);
    AttackStep.allAttackSteps.remove(highPrivilegesAchieved);
    highPrivilegesAchieved = new HighPrivilegesAchieved(name);
    AttackStep.allAttackSteps.remove(userInteractionAchieved);
    userInteractionAchieved = new UserInteractionAchieved(name);
    AttackStep.allAttackSteps.remove(impact);
    impact = new Impact(name);
    AttackStep.allAttackSteps.remove(read);
    read = new Read(name);
    AttackStep.allAttackSteps.remove(modify);
    modify = new Modify(name);
    AttackStep.allAttackSteps.remove(deny);
    deny = new Deny(name);
    AttackStep.allAttackSteps.remove(attemptAbuse);
    attemptAbuse = new AttemptAbuse(name);
    AttackStep.allAttackSteps.remove(attemptExploit);
    attemptExploit = new AttemptExploit(name);
    AttackStep.allAttackSteps.remove(exploitTrivially);
    exploitTrivially = new ExploitTrivially(name);
    AttackStep.allAttackSteps.remove(exploitWithEffort);
    exploitWithEffort = new ExploitWithEffort(name);
  }

  public SoftwareVulnerability(String name) {
    super(name);
    assetClassName = "SoftwareVulnerability";
    if (networkAccessRequired != null) {
      AttackStep.allAttackSteps.remove(networkAccessRequired.disable);
    }
    Defense.allDefenses.remove(networkAccessRequired);
    networkAccessRequired = new NetworkAccessRequired(name, false);
    if (localAccessRequired != null) {
      AttackStep.allAttackSteps.remove(localAccessRequired.disable);
    }
    Defense.allDefenses.remove(localAccessRequired);
    localAccessRequired = new LocalAccessRequired(name, false);
    if (physicalAccessRequired != null) {
      AttackStep.allAttackSteps.remove(physicalAccessRequired.disable);
    }
    Defense.allDefenses.remove(physicalAccessRequired);
    physicalAccessRequired = new PhysicalAccessRequired(name, false);
    if (lowPrivilegesRequired != null) {
      AttackStep.allAttackSteps.remove(lowPrivilegesRequired.disable);
    }
    Defense.allDefenses.remove(lowPrivilegesRequired);
    lowPrivilegesRequired = new LowPrivilegesRequired(name, false);
    if (highPrivilegesRequired != null) {
      AttackStep.allAttackSteps.remove(highPrivilegesRequired.disable);
    }
    Defense.allDefenses.remove(highPrivilegesRequired);
    highPrivilegesRequired = new HighPrivilegesRequired(name, false);
    if (userInteractionRequired != null) {
      AttackStep.allAttackSteps.remove(userInteractionRequired.disable);
    }
    Defense.allDefenses.remove(userInteractionRequired);
    userInteractionRequired = new UserInteractionRequired(name, false);
    if (confidentialityImpactLimitations != null) {
      AttackStep.allAttackSteps.remove(confidentialityImpactLimitations.disable);
    }
    Defense.allDefenses.remove(confidentialityImpactLimitations);
    confidentialityImpactLimitations = new ConfidentialityImpactLimitations(name, false);
    if (availabilityImpactLimitations != null) {
      AttackStep.allAttackSteps.remove(availabilityImpactLimitations.disable);
    }
    Defense.allDefenses.remove(availabilityImpactLimitations);
    availabilityImpactLimitations = new AvailabilityImpactLimitations(name, false);
    if (integrityImpactLimitations != null) {
      AttackStep.allAttackSteps.remove(integrityImpactLimitations.disable);
    }
    Defense.allDefenses.remove(integrityImpactLimitations);
    integrityImpactLimitations = new IntegrityImpactLimitations(name, false);
    if (highComplexityExploitRequired != null) {
      AttackStep.allAttackSteps.remove(highComplexityExploitRequired.disable);
    }
    Defense.allDefenses.remove(highComplexityExploitRequired);
    highComplexityExploitRequired = new HighComplexityExploitRequired(name, false);
    AttackStep.allAttackSteps.remove(inherentUserInteraction);
    inherentUserInteraction = new InherentUserInteraction(name);
    AttackStep.allAttackSteps.remove(networkAccessAchieved);
    networkAccessAchieved = new NetworkAccessAchieved(name);
    AttackStep.allAttackSteps.remove(localAccessAchieved);
    localAccessAchieved = new LocalAccessAchieved(name);
    AttackStep.allAttackSteps.remove(physicalAccessAchieved);
    physicalAccessAchieved = new PhysicalAccessAchieved(name);
    AttackStep.allAttackSteps.remove(lowPrivilegesAchieved);
    lowPrivilegesAchieved = new LowPrivilegesAchieved(name);
    AttackStep.allAttackSteps.remove(highPrivilegesAchieved);
    highPrivilegesAchieved = new HighPrivilegesAchieved(name);
    AttackStep.allAttackSteps.remove(userInteractionAchieved);
    userInteractionAchieved = new UserInteractionAchieved(name);
    AttackStep.allAttackSteps.remove(impact);
    impact = new Impact(name);
    AttackStep.allAttackSteps.remove(read);
    read = new Read(name);
    AttackStep.allAttackSteps.remove(modify);
    modify = new Modify(name);
    AttackStep.allAttackSteps.remove(deny);
    deny = new Deny(name);
    AttackStep.allAttackSteps.remove(attemptAbuse);
    attemptAbuse = new AttemptAbuse(name);
    AttackStep.allAttackSteps.remove(attemptExploit);
    attemptExploit = new AttemptExploit(name);
    AttackStep.allAttackSteps.remove(exploitTrivially);
    exploitTrivially = new ExploitTrivially(name);
    AttackStep.allAttackSteps.remove(exploitWithEffort);
    exploitWithEffort = new ExploitWithEffort(name);
  }

  public SoftwareVulnerability(boolean isNotPresentEnabled, boolean isNetworkAccessRequiredEnabled,
      boolean isLocalAccessRequiredEnabled, boolean isPhysicalAccessRequiredEnabled,
      boolean isLowPrivilegesRequiredEnabled, boolean isHighPrivilegesRequiredEnabled,
      boolean isUserInteractionRequiredEnabled, boolean isConfidentialityImpactLimitationsEnabled,
      boolean isAvailabilityImpactLimitationsEnabled, boolean isIntegrityImpactLimitationsEnabled,
      boolean isHighComplexityExploitRequiredEnabled) {
    this("Anonymous", isNotPresentEnabled, isNetworkAccessRequiredEnabled, isLocalAccessRequiredEnabled, isPhysicalAccessRequiredEnabled, isLowPrivilegesRequiredEnabled, isHighPrivilegesRequiredEnabled, isUserInteractionRequiredEnabled, isConfidentialityImpactLimitationsEnabled, isAvailabilityImpactLimitationsEnabled, isIntegrityImpactLimitationsEnabled, isHighComplexityExploitRequiredEnabled);
  }

  public SoftwareVulnerability() {
    this("Anonymous");
  }

  protected Set<Application> _reverseallVulnerabilitiesApplication() {
    if (_cachereverseallVulnerabilitiesApplication == null) {
      _cachereverseallVulnerabilitiesApplication = new HashSet<>();
      Set<Application> _0 = new HashSet<>();
      Set<Application> _1 = new HashSet<>();
      if (softwareProduct != null) {
        for (Application _2 : softwareProduct.softApplications) {
          _0.add(_2);
        }
      }
      if (application != null) {
        _1.add(application);
      }
      _0.addAll(_1);
      for (Application _3 : _0) {
        _cachereverseallVulnerabilitiesApplication.add(_3);
      }
    }
    return _cachereverseallVulnerabilitiesApplication;
  }

  public void addApplication(Application application) {
    this.application = application;
    application.vulnerabilities.add(this);
  }

  public void addSoftwareProduct(SoftwareProduct softwareProduct) {
    this.softwareProduct = softwareProduct;
    softwareProduct.softProductVulnerabilities.add(this);
  }

  @Override
  public String getAssociatedAssetClassName(String field) {
    if (field.equals("application")) {
      return Application.class.getName();
    } else if (field.equals("softwareProduct")) {
      return SoftwareProduct.class.getName();
    }
    return "";
  }

  @Override
  public Set<Asset> getAssociatedAssets(String field) {
    Set<Asset> assets = new HashSet<>();
    if (field.equals("application")) {
      if (application != null) {
        assets.add(application);
      }
    } else if (field.equals("softwareProduct")) {
      if (softwareProduct != null) {
        assets.add(softwareProduct);
      }
    }
    return assets;
  }

  @Override
  public Set<Asset> getAllAssociatedAssets() {
    Set<Asset> assets = new HashSet<>();
    if (application != null) {
      assets.add(application);
    }
    if (softwareProduct != null) {
      assets.add(softwareProduct);
    }
    return assets;
  }

  public class NetworkAccessRequired extends Defense {
    public NetworkAccessRequired(String name) {
      this(name, false);
    }

    public NetworkAccessRequired(String name, Boolean isEnabled) {
      super(name);
      defaultValue = isEnabled;
      disable = new Disable(name);
    }

    public class Disable extends AttackStepMin {
      private Set<AttackStep> _cacheChildrenNetworkAccessRequired;

      public Disable(String name) {
        super(name);
      }

      @Override
      public void updateChildren(Set<AttackStep> attackSteps) {
        if (_cacheChildrenNetworkAccessRequired == null) {
          _cacheChildrenNetworkAccessRequired = new HashSet<>();
          _cacheChildrenNetworkAccessRequired.add(networkAccessAchieved);
          if (softwareProduct != null) {
            for (Application _0 : softwareProduct.softApplications) {
              _cacheChildrenNetworkAccessRequired.add(_0.softwareProductVulnerabilityNetworkAccessAchieved);
            }
          }
        }
        for (AttackStep attackStep : _cacheChildrenNetworkAccessRequired) {
          attackStep.updateTtc(this, ttc, attackSteps);
        }
      }

      @Override
      public String fullName() {
        return "SoftwareVulnerability.networkAccessRequired";
      }
    }
  }

  public class LocalAccessRequired extends Defense {
    public LocalAccessRequired(String name) {
      this(name, false);
    }

    public LocalAccessRequired(String name, Boolean isEnabled) {
      super(name);
      defaultValue = isEnabled;
      disable = new Disable(name);
    }

    public class Disable extends AttackStepMin {
      private Set<AttackStep> _cacheChildrenLocalAccessRequired;

      public Disable(String name) {
        super(name);
      }

      @Override
      public void updateChildren(Set<AttackStep> attackSteps) {
        if (_cacheChildrenLocalAccessRequired == null) {
          _cacheChildrenLocalAccessRequired = new HashSet<>();
          _cacheChildrenLocalAccessRequired.add(localAccessAchieved);
          if (softwareProduct != null) {
            for (Application _0 : softwareProduct.softApplications) {
              _cacheChildrenLocalAccessRequired.add(_0.softwareProductVulnerabilityLocalAccessAchieved);
            }
          }
        }
        for (AttackStep attackStep : _cacheChildrenLocalAccessRequired) {
          attackStep.updateTtc(this, ttc, attackSteps);
        }
      }

      @Override
      public String fullName() {
        return "SoftwareVulnerability.localAccessRequired";
      }
    }
  }

  public class PhysicalAccessRequired extends Defense {
    public PhysicalAccessRequired(String name) {
      this(name, false);
    }

    public PhysicalAccessRequired(String name, Boolean isEnabled) {
      super(name);
      defaultValue = isEnabled;
      disable = new Disable(name);
    }

    public class Disable extends AttackStepMin {
      private Set<AttackStep> _cacheChildrenPhysicalAccessRequired;

      public Disable(String name) {
        super(name);
      }

      @Override
      public void updateChildren(Set<AttackStep> attackSteps) {
        if (_cacheChildrenPhysicalAccessRequired == null) {
          _cacheChildrenPhysicalAccessRequired = new HashSet<>();
          _cacheChildrenPhysicalAccessRequired.add(physicalAccessAchieved);
          if (softwareProduct != null) {
            for (Application _0 : softwareProduct.softApplications) {
              _cacheChildrenPhysicalAccessRequired.add(_0.softwareProductVulnerabilityPhysicalAccessAchieved);
            }
          }
        }
        for (AttackStep attackStep : _cacheChildrenPhysicalAccessRequired) {
          attackStep.updateTtc(this, ttc, attackSteps);
        }
      }

      @Override
      public String fullName() {
        return "SoftwareVulnerability.physicalAccessRequired";
      }
    }
  }

  public class LowPrivilegesRequired extends Defense {
    public LowPrivilegesRequired(String name) {
      this(name, false);
    }

    public LowPrivilegesRequired(String name, Boolean isEnabled) {
      super(name);
      defaultValue = isEnabled;
      disable = new Disable(name);
    }

    public class Disable extends AttackStepMin {
      private Set<AttackStep> _cacheChildrenLowPrivilegesRequired;

      public Disable(String name) {
        super(name);
      }

      @Override
      public void updateChildren(Set<AttackStep> attackSteps) {
        if (_cacheChildrenLowPrivilegesRequired == null) {
          _cacheChildrenLowPrivilegesRequired = new HashSet<>();
          _cacheChildrenLowPrivilegesRequired.add(lowPrivilegesAchieved);
          if (softwareProduct != null) {
            for (Application _0 : softwareProduct.softApplications) {
              _cacheChildrenLowPrivilegesRequired.add(_0.softwareProductVulnerabilityLowPrivilegesAchieved);
            }
          }
        }
        for (AttackStep attackStep : _cacheChildrenLowPrivilegesRequired) {
          attackStep.updateTtc(this, ttc, attackSteps);
        }
      }

      @Override
      public String fullName() {
        return "SoftwareVulnerability.lowPrivilegesRequired";
      }
    }
  }

  public class HighPrivilegesRequired extends Defense {
    public HighPrivilegesRequired(String name) {
      this(name, false);
    }

    public HighPrivilegesRequired(String name, Boolean isEnabled) {
      super(name);
      defaultValue = isEnabled;
      disable = new Disable(name);
    }

    public class Disable extends AttackStepMin {
      private Set<AttackStep> _cacheChildrenHighPrivilegesRequired;

      public Disable(String name) {
        super(name);
      }

      @Override
      public void updateChildren(Set<AttackStep> attackSteps) {
        if (_cacheChildrenHighPrivilegesRequired == null) {
          _cacheChildrenHighPrivilegesRequired = new HashSet<>();
          _cacheChildrenHighPrivilegesRequired.add(highPrivilegesAchieved);
          if (softwareProduct != null) {
            for (Application _0 : softwareProduct.softApplications) {
              _cacheChildrenHighPrivilegesRequired.add(_0.softwareProductVulnerabilityHighPrivilegesAchieved);
            }
          }
        }
        for (AttackStep attackStep : _cacheChildrenHighPrivilegesRequired) {
          attackStep.updateTtc(this, ttc, attackSteps);
        }
      }

      @Override
      public String fullName() {
        return "SoftwareVulnerability.highPrivilegesRequired";
      }
    }
  }

  public class UserInteractionRequired extends Defense {
    public UserInteractionRequired(String name) {
      this(name, false);
    }

    public UserInteractionRequired(String name, Boolean isEnabled) {
      super(name);
      defaultValue = isEnabled;
      disable = new Disable(name);
    }

    public class Disable extends AttackStepMin {
      private Set<AttackStep> _cacheChildrenUserInteractionRequired;

      public Disable(String name) {
        super(name);
      }

      @Override
      public void updateChildren(Set<AttackStep> attackSteps) {
        if (_cacheChildrenUserInteractionRequired == null) {
          _cacheChildrenUserInteractionRequired = new HashSet<>();
          _cacheChildrenUserInteractionRequired.add(userInteractionAchieved);
          if (softwareProduct != null) {
            for (Application _0 : softwareProduct.softApplications) {
              _cacheChildrenUserInteractionRequired.add(_0.softwareProductVulnerabilityUserInteractionAchieved);
            }
          }
        }
        for (AttackStep attackStep : _cacheChildrenUserInteractionRequired) {
          attackStep.updateTtc(this, ttc, attackSteps);
        }
      }

      @Override
      public String fullName() {
        return "SoftwareVulnerability.userInteractionRequired";
      }
    }
  }

  public class ConfidentialityImpactLimitations extends Defense {
    public ConfidentialityImpactLimitations(String name) {
      this(name, false);
    }

    public ConfidentialityImpactLimitations(String name, Boolean isEnabled) {
      super(name);
      defaultValue = isEnabled;
      disable = new Disable(name);
    }

    public class Disable extends AttackStepMin {
      private Set<AttackStep> _cacheChildrenConfidentialityImpactLimitations;

      public Disable(String name) {
        super(name);
      }

      @Override
      public void updateChildren(Set<AttackStep> attackSteps) {
        if (_cacheChildrenConfidentialityImpactLimitations == null) {
          _cacheChildrenConfidentialityImpactLimitations = new HashSet<>();
          _cacheChildrenConfidentialityImpactLimitations.add(read);
        }
        for (AttackStep attackStep : _cacheChildrenConfidentialityImpactLimitations) {
          attackStep.updateTtc(this, ttc, attackSteps);
        }
      }

      @Override
      public String fullName() {
        return "SoftwareVulnerability.confidentialityImpactLimitations";
      }
    }
  }

  public class AvailabilityImpactLimitations extends Defense {
    public AvailabilityImpactLimitations(String name) {
      this(name, false);
    }

    public AvailabilityImpactLimitations(String name, Boolean isEnabled) {
      super(name);
      defaultValue = isEnabled;
      disable = new Disable(name);
    }

    public class Disable extends AttackStepMin {
      private Set<AttackStep> _cacheChildrenAvailabilityImpactLimitations;

      public Disable(String name) {
        super(name);
      }

      @Override
      public void updateChildren(Set<AttackStep> attackSteps) {
        if (_cacheChildrenAvailabilityImpactLimitations == null) {
          _cacheChildrenAvailabilityImpactLimitations = new HashSet<>();
          _cacheChildrenAvailabilityImpactLimitations.add(deny);
        }
        for (AttackStep attackStep : _cacheChildrenAvailabilityImpactLimitations) {
          attackStep.updateTtc(this, ttc, attackSteps);
        }
      }

      @Override
      public String fullName() {
        return "SoftwareVulnerability.availabilityImpactLimitations";
      }
    }
  }

  public class IntegrityImpactLimitations extends Defense {
    public IntegrityImpactLimitations(String name) {
      this(name, false);
    }

    public IntegrityImpactLimitations(String name, Boolean isEnabled) {
      super(name);
      defaultValue = isEnabled;
      disable = new Disable(name);
    }

    public class Disable extends AttackStepMin {
      private Set<AttackStep> _cacheChildrenIntegrityImpactLimitations;

      public Disable(String name) {
        super(name);
      }

      @Override
      public void updateChildren(Set<AttackStep> attackSteps) {
        if (_cacheChildrenIntegrityImpactLimitations == null) {
          _cacheChildrenIntegrityImpactLimitations = new HashSet<>();
          _cacheChildrenIntegrityImpactLimitations.add(modify);
        }
        for (AttackStep attackStep : _cacheChildrenIntegrityImpactLimitations) {
          attackStep.updateTtc(this, ttc, attackSteps);
        }
      }

      @Override
      public String fullName() {
        return "SoftwareVulnerability.integrityImpactLimitations";
      }
    }
  }

  public class HighComplexityExploitRequired extends Defense {
    public HighComplexityExploitRequired(String name) {
      this(name, false);
    }

    public HighComplexityExploitRequired(String name, Boolean isEnabled) {
      super(name);
      defaultValue = isEnabled;
      disable = new Disable(name);
    }

    public class Disable extends AttackStepMin {
      private Set<AttackStep> _cacheChildrenHighComplexityExploitRequired;

      public Disable(String name) {
        super(name);
      }

      @Override
      public void updateChildren(Set<AttackStep> attackSteps) {
        if (_cacheChildrenHighComplexityExploitRequired == null) {
          _cacheChildrenHighComplexityExploitRequired = new HashSet<>();
          _cacheChildrenHighComplexityExploitRequired.add(exploitTrivially);
        }
        for (AttackStep attackStep : _cacheChildrenHighComplexityExploitRequired) {
          attackStep.updateTtc(this, ttc, attackSteps);
        }
      }

      @Override
      public String fullName() {
        return "SoftwareVulnerability.highComplexityExploitRequired";
      }
    }
  }

  public class InherentUserInteraction extends AttackStepMin {
    private Set<AttackStep> _cacheChildrenInherentUserInteraction;

    private Set<AttackStep> _cacheParentInherentUserInteraction;

    public InherentUserInteraction(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenInherentUserInteraction == null) {
        _cacheChildrenInherentUserInteraction = new HashSet<>();
        _cacheChildrenInherentUserInteraction.add(userInteractionAchieved);
        if (softwareProduct != null) {
          for (Application _0 : softwareProduct.softApplications) {
            _cacheChildrenInherentUserInteraction.add(_0.softwareProductVulnerabilityUserInteractionAchieved);
          }
        }
      }
      for (AttackStep attackStep : _cacheChildrenInherentUserInteraction) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentInherentUserInteraction == null) {
        _cacheParentInherentUserInteraction = new HashSet<>();
        _cacheParentInherentUserInteraction.add(attemptAbuse);
      }
      for (AttackStep attackStep : _cacheParentInherentUserInteraction) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("SoftwareVulnerability.inherentUserInteraction");
    }
  }

  public class NetworkAccessAchieved extends AttackStepMin {
    private Set<AttackStep> _cacheChildrenNetworkAccessAchieved;

    private Set<AttackStep> _cacheParentNetworkAccessAchieved;

    public NetworkAccessAchieved(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenNetworkAccessAchieved == null) {
        _cacheChildrenNetworkAccessAchieved = new HashSet<>();
        if (SoftwareVulnerability.this instanceof SoftwareVulnerability) {
          _cacheChildrenNetworkAccessAchieved.add(((org.mal_lang.redigoLang.test.SoftwareVulnerability) SoftwareVulnerability.this).abuse);
        }
      }
      for (AttackStep attackStep : _cacheChildrenNetworkAccessAchieved) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentNetworkAccessAchieved == null) {
        _cacheParentNetworkAccessAchieved = new HashSet<>();
        for (var _0 : _reverseallVulnerabilitiesApplication()) {
          _cacheParentNetworkAccessAchieved.add(_0.networkConnectUninspected);
        }
        if (softwareProduct != null) {
          for (Application _1 : softwareProduct.softApplications) {
            _cacheParentNetworkAccessAchieved.add(_1.softwareProductVulnerabilityNetworkAccessAchieved);
          }
        }
        _cacheParentNetworkAccessAchieved.add(networkAccessRequired.disable);
      }
      for (AttackStep attackStep : _cacheParentNetworkAccessAchieved) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("SoftwareVulnerability.networkAccessAchieved");
    }
  }

  public class LocalAccessAchieved extends AttackStepMin {
    private Set<AttackStep> _cacheChildrenLocalAccessAchieved;

    private Set<AttackStep> _cacheParentLocalAccessAchieved;

    public LocalAccessAchieved(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenLocalAccessAchieved == null) {
        _cacheChildrenLocalAccessAchieved = new HashSet<>();
        if (SoftwareVulnerability.this instanceof SoftwareVulnerability) {
          _cacheChildrenLocalAccessAchieved.add(((org.mal_lang.redigoLang.test.SoftwareVulnerability) SoftwareVulnerability.this).abuse);
        }
      }
      for (AttackStep attackStep : _cacheChildrenLocalAccessAchieved) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentLocalAccessAchieved == null) {
        _cacheParentLocalAccessAchieved = new HashSet<>();
        for (var _0 : _reverseallVulnerabilitiesApplication()) {
          _cacheParentLocalAccessAchieved.add(_0.localConnect);
        }
        if (softwareProduct != null) {
          for (Application _1 : softwareProduct.softApplications) {
            _cacheParentLocalAccessAchieved.add(_1.softwareProductVulnerabilityLocalAccessAchieved);
          }
        }
        _cacheParentLocalAccessAchieved.add(localAccessRequired.disable);
      }
      for (AttackStep attackStep : _cacheParentLocalAccessAchieved) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("SoftwareVulnerability.localAccessAchieved");
    }
  }

  public class PhysicalAccessAchieved extends AttackStepMin {
    private Set<AttackStep> _cacheChildrenPhysicalAccessAchieved;

    private Set<AttackStep> _cacheParentPhysicalAccessAchieved;

    public PhysicalAccessAchieved(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenPhysicalAccessAchieved == null) {
        _cacheChildrenPhysicalAccessAchieved = new HashSet<>();
        if (SoftwareVulnerability.this instanceof SoftwareVulnerability) {
          _cacheChildrenPhysicalAccessAchieved.add(((org.mal_lang.redigoLang.test.SoftwareVulnerability) SoftwareVulnerability.this).abuse);
        }
      }
      for (AttackStep attackStep : _cacheChildrenPhysicalAccessAchieved) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentPhysicalAccessAchieved == null) {
        _cacheParentPhysicalAccessAchieved = new HashSet<>();
        for (var _0 : _reverseallVulnerabilitiesApplication()) {
          _cacheParentPhysicalAccessAchieved.add(_0.physicalAccessAchieved);
        }
        if (softwareProduct != null) {
          for (Application _1 : softwareProduct.softApplications) {
            _cacheParentPhysicalAccessAchieved.add(_1.softwareProductVulnerabilityPhysicalAccessAchieved);
          }
        }
        _cacheParentPhysicalAccessAchieved.add(physicalAccessRequired.disable);
      }
      for (AttackStep attackStep : _cacheParentPhysicalAccessAchieved) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("SoftwareVulnerability.physicalAccessAchieved");
    }
  }

  public class LowPrivilegesAchieved extends AttackStepMin {
    private Set<AttackStep> _cacheChildrenLowPrivilegesAchieved;

    private Set<AttackStep> _cacheParentLowPrivilegesAchieved;

    public LowPrivilegesAchieved(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenLowPrivilegesAchieved == null) {
        _cacheChildrenLowPrivilegesAchieved = new HashSet<>();
        if (SoftwareVulnerability.this instanceof SoftwareVulnerability) {
          _cacheChildrenLowPrivilegesAchieved.add(((org.mal_lang.redigoLang.test.SoftwareVulnerability) SoftwareVulnerability.this).abuse);
        }
      }
      for (AttackStep attackStep : _cacheChildrenLowPrivilegesAchieved) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentLowPrivilegesAchieved == null) {
        _cacheParentLowPrivilegesAchieved = new HashSet<>();
        for (var _0 : _reverseallVulnerabilitiesApplication()) {
          _cacheParentLowPrivilegesAchieved.add(_0.specificAccessAuthenticate);
        }
        if (softwareProduct != null) {
          for (Application _1 : softwareProduct.softApplications) {
            _cacheParentLowPrivilegesAchieved.add(_1.softwareProductVulnerabilityLowPrivilegesAchieved);
          }
        }
        _cacheParentLowPrivilegesAchieved.add(lowPrivilegesRequired.disable);
      }
      for (AttackStep attackStep : _cacheParentLowPrivilegesAchieved) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("SoftwareVulnerability.lowPrivilegesAchieved");
    }
  }

  public class HighPrivilegesAchieved extends AttackStepMin {
    private Set<AttackStep> _cacheChildrenHighPrivilegesAchieved;

    private Set<AttackStep> _cacheParentHighPrivilegesAchieved;

    public HighPrivilegesAchieved(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenHighPrivilegesAchieved == null) {
        _cacheChildrenHighPrivilegesAchieved = new HashSet<>();
        if (SoftwareVulnerability.this instanceof SoftwareVulnerability) {
          _cacheChildrenHighPrivilegesAchieved.add(((org.mal_lang.redigoLang.test.SoftwareVulnerability) SoftwareVulnerability.this).abuse);
        }
      }
      for (AttackStep attackStep : _cacheChildrenHighPrivilegesAchieved) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentHighPrivilegesAchieved == null) {
        _cacheParentHighPrivilegesAchieved = new HashSet<>();
        for (var _0 : _reverseallVulnerabilitiesApplication()) {
          _cacheParentHighPrivilegesAchieved.add(_0.authenticate);
        }
        if (softwareProduct != null) {
          for (Application _1 : softwareProduct.softApplications) {
            _cacheParentHighPrivilegesAchieved.add(_1.softwareProductVulnerabilityHighPrivilegesAchieved);
          }
        }
        _cacheParentHighPrivilegesAchieved.add(highPrivilegesRequired.disable);
      }
      for (AttackStep attackStep : _cacheParentHighPrivilegesAchieved) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("SoftwareVulnerability.highPrivilegesAchieved");
    }
  }

  public class UserInteractionAchieved extends AttackStepMin {
    private Set<AttackStep> _cacheChildrenUserInteractionAchieved;

    private Set<AttackStep> _cacheParentUserInteractionAchieved;

    public UserInteractionAchieved(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenUserInteractionAchieved == null) {
        _cacheChildrenUserInteractionAchieved = new HashSet<>();
        if (SoftwareVulnerability.this instanceof SoftwareVulnerability) {
          _cacheChildrenUserInteractionAchieved.add(((org.mal_lang.redigoLang.test.SoftwareVulnerability) SoftwareVulnerability.this).abuse);
        }
      }
      for (AttackStep attackStep : _cacheChildrenUserInteractionAchieved) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentUserInteractionAchieved == null) {
        _cacheParentUserInteractionAchieved = new HashSet<>();
        for (var _0 : _reverseallVulnerabilitiesApplication()) {
          _cacheParentUserInteractionAchieved.add(_0.unsafeUserActivity);
        }
        if (softwareProduct != null) {
          for (Application _1 : softwareProduct.softApplications) {
            _cacheParentUserInteractionAchieved.add(_1.softwareProductVulnerabilityUserInteractionAchieved);
          }
        }
        _cacheParentUserInteractionAchieved.add(userInteractionRequired.disable);
        _cacheParentUserInteractionAchieved.add(inherentUserInteraction);
      }
      for (AttackStep attackStep : _cacheParentUserInteractionAchieved) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("SoftwareVulnerability.userInteractionAchieved");
    }
  }

  public class Impact extends Vulnerability.Impact {
    private Set<AttackStep> _cacheChildrenImpact;

    public Impact(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenImpact == null) {
        _cacheChildrenImpact = new HashSet<>();
        _cacheChildrenImpact.add(read);
        _cacheChildrenImpact.add(modify);
        _cacheChildrenImpact.add(deny);
      }
      for (AttackStep attackStep : _cacheChildrenImpact) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("SoftwareVulnerability.impact");
    }
  }

  public class Read extends AttackStepMax {
    private Set<AttackStep> _cacheChildrenRead;

    private Set<AttackStep> _cacheParentRead;

    public Read(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenRead == null) {
        _cacheChildrenRead = new HashSet<>();
        if (application != null) {
          _cacheChildrenRead.add(application.read);
        }
        if (softwareProduct != null) {
          _cacheChildrenRead.add(softwareProduct.readApplications);
        }
      }
      for (AttackStep attackStep : _cacheChildrenRead) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentRead == null) {
        _cacheParentRead = new HashSet<>();
        _cacheParentRead.add(confidentialityImpactLimitations.disable);
        _cacheParentRead.add(impact);
      }
      for (AttackStep attackStep : _cacheParentRead) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("SoftwareVulnerability.read");
    }
  }

  public class Modify extends AttackStepMax {
    private Set<AttackStep> _cacheChildrenModify;

    private Set<AttackStep> _cacheParentModify;

    public Modify(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenModify == null) {
        _cacheChildrenModify = new HashSet<>();
        if (application != null) {
          _cacheChildrenModify.add(application.modify);
        }
        if (softwareProduct != null) {
          _cacheChildrenModify.add(softwareProduct.modifyApplications);
        }
      }
      for (AttackStep attackStep : _cacheChildrenModify) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentModify == null) {
        _cacheParentModify = new HashSet<>();
        _cacheParentModify.add(integrityImpactLimitations.disable);
        _cacheParentModify.add(impact);
      }
      for (AttackStep attackStep : _cacheParentModify) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("SoftwareVulnerability.modify");
    }
  }

  public class Deny extends AttackStepMax {
    private Set<AttackStep> _cacheChildrenDeny;

    private Set<AttackStep> _cacheParentDeny;

    public Deny(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenDeny == null) {
        _cacheChildrenDeny = new HashSet<>();
        if (application != null) {
          _cacheChildrenDeny.add(application.deny);
        }
        if (softwareProduct != null) {
          _cacheChildrenDeny.add(softwareProduct.denyApplications);
        }
      }
      for (AttackStep attackStep : _cacheChildrenDeny) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentDeny == null) {
        _cacheParentDeny = new HashSet<>();
        _cacheParentDeny.add(availabilityImpactLimitations.disable);
        _cacheParentDeny.add(impact);
      }
      for (AttackStep attackStep : _cacheParentDeny) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("SoftwareVulnerability.deny");
    }
  }

  public class AttemptAbuse extends Vulnerability.AttemptAbuse {
    private Set<AttackStep> _cacheChildrenAttemptAbuse;

    private Set<AttackStep> _cacheParentAttemptAbuse;

    public AttemptAbuse(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      super.updateChildren(attackSteps);
      if (_cacheChildrenAttemptAbuse == null) {
        _cacheChildrenAttemptAbuse = new HashSet<>();
        _cacheChildrenAttemptAbuse.add(inherentUserInteraction);
      }
      for (AttackStep attackStep : _cacheChildrenAttemptAbuse) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentAttemptAbuse == null) {
        _cacheParentAttemptAbuse = new HashSet<>();
        for (var _0 : _reverseallVulnerabilitiesApplication()) {
          _cacheParentAttemptAbuse.add(_0.useVulnerability);
        }
      }
      for (AttackStep attackStep : _cacheParentAttemptAbuse) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("SoftwareVulnerability.attemptAbuse");
    }
  }

  public class AttemptExploit extends Vulnerability.AttemptExploit {
    private Set<AttackStep> _cacheChildrenAttemptExploit;

    public AttemptExploit(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenAttemptExploit == null) {
        _cacheChildrenAttemptExploit = new HashSet<>();
        _cacheChildrenAttemptExploit.add(exploitTrivially);
        _cacheChildrenAttemptExploit.add(exploitWithEffort);
      }
      for (AttackStep attackStep : _cacheChildrenAttemptExploit) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("SoftwareVulnerability.attemptExploit");
    }
  }

  public class ExploitTrivially extends AttackStepMax {
    private Set<AttackStep> _cacheChildrenExploitTrivially;

    private Set<AttackStep> _cacheParentExploitTrivially;

    public ExploitTrivially(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenExploitTrivially == null) {
        _cacheChildrenExploitTrivially = new HashSet<>();
        if (SoftwareVulnerability.this instanceof SoftwareVulnerability) {
          _cacheChildrenExploitTrivially.add(((org.mal_lang.redigoLang.test.SoftwareVulnerability) SoftwareVulnerability.this).exploit);
        }
      }
      for (AttackStep attackStep : _cacheChildrenExploitTrivially) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentExploitTrivially == null) {
        _cacheParentExploitTrivially = new HashSet<>();
        _cacheParentExploitTrivially.add(highComplexityExploitRequired.disable);
        _cacheParentExploitTrivially.add(attemptExploit);
      }
      for (AttackStep attackStep : _cacheParentExploitTrivially) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("SoftwareVulnerability.exploitTrivially");
    }
  }

  public class ExploitWithEffort extends AttackStepMax {
    private Set<AttackStep> _cacheChildrenExploitWithEffort;

    private Set<AttackStep> _cacheParentExploitWithEffort;

    public ExploitWithEffort(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenExploitWithEffort == null) {
        _cacheChildrenExploitWithEffort = new HashSet<>();
        if (SoftwareVulnerability.this instanceof SoftwareVulnerability) {
          _cacheChildrenExploitWithEffort.add(((org.mal_lang.redigoLang.test.SoftwareVulnerability) SoftwareVulnerability.this).exploit);
        }
      }
      for (AttackStep attackStep : _cacheChildrenExploitWithEffort) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentExploitWithEffort == null) {
        _cacheParentExploitWithEffort = new HashSet<>();
        _cacheParentExploitWithEffort.add(attemptExploit);
      }
      for (AttackStep attackStep : _cacheParentExploitWithEffort) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("SoftwareVulnerability.exploitWithEffort");
    }
  }
}
