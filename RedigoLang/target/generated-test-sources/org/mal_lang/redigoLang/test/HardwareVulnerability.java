package org.mal_lang.redigoLang.test;

import core.Asset;
import core.AttackStep;
import core.AttackStepMax;
import core.AttackStepMin;
import core.Defense;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.util.HashSet;
import java.util.Set;

public class HardwareVulnerability extends Vulnerability {
  public PhysicalAccessRequired physicalAccessRequired;

  public ConfidentialityImpactLimitations confidentialityImpactLimitations;

  public AvailabilityImpactLimitations availabilityImpactLimitations;

  public IntegrityImpactLimitations integrityImpactLimitations;

  public EffortRequiredToExploit effortRequiredToExploit;

  public PhysicalAccessAchieved physicalAccessAchieved;

  public Read read;

  public Modify modify;

  public Deny deny;

  public ExploitTrivially exploitTrivially;

  public ExploitWithEffort exploitWithEffort;

  public Hardware hardware = null;

  public HardwareVulnerability(String name, boolean isNotPresentEnabled,
      boolean isPhysicalAccessRequiredEnabled, boolean isConfidentialityImpactLimitationsEnabled,
      boolean isAvailabilityImpactLimitationsEnabled, boolean isIntegrityImpactLimitationsEnabled,
      boolean isEffortRequiredToExploitEnabled) {
    super(name, isNotPresentEnabled);
    assetClassName = "HardwareVulnerability";
    if (physicalAccessRequired != null) {
      AttackStep.allAttackSteps.remove(physicalAccessRequired.disable);
    }
    Defense.allDefenses.remove(physicalAccessRequired);
    physicalAccessRequired = new PhysicalAccessRequired(name, isPhysicalAccessRequiredEnabled);
    if (confidentialityImpactLimitations != null) {
      AttackStep.allAttackSteps.remove(confidentialityImpactLimitations.disable);
    }
    Defense.allDefenses.remove(confidentialityImpactLimitations);
    confidentialityImpactLimitations = new ConfidentialityImpactLimitations(name, isConfidentialityImpactLimitationsEnabled);
    if (availabilityImpactLimitations != null) {
      AttackStep.allAttackSteps.remove(availabilityImpactLimitations.disable);
    }
    Defense.allDefenses.remove(availabilityImpactLimitations);
    availabilityImpactLimitations = new AvailabilityImpactLimitations(name, isAvailabilityImpactLimitationsEnabled);
    if (integrityImpactLimitations != null) {
      AttackStep.allAttackSteps.remove(integrityImpactLimitations.disable);
    }
    Defense.allDefenses.remove(integrityImpactLimitations);
    integrityImpactLimitations = new IntegrityImpactLimitations(name, isIntegrityImpactLimitationsEnabled);
    if (effortRequiredToExploit != null) {
      AttackStep.allAttackSteps.remove(effortRequiredToExploit.disable);
    }
    Defense.allDefenses.remove(effortRequiredToExploit);
    effortRequiredToExploit = new EffortRequiredToExploit(name, isEffortRequiredToExploitEnabled);
    AttackStep.allAttackSteps.remove(physicalAccessAchieved);
    physicalAccessAchieved = new PhysicalAccessAchieved(name);
    AttackStep.allAttackSteps.remove(impact);
    impact = new Impact(name);
    AttackStep.allAttackSteps.remove(read);
    read = new Read(name);
    AttackStep.allAttackSteps.remove(modify);
    modify = new Modify(name);
    AttackStep.allAttackSteps.remove(deny);
    deny = new Deny(name);
    AttackStep.allAttackSteps.remove(attemptExploit);
    attemptExploit = new AttemptExploit(name);
    AttackStep.allAttackSteps.remove(exploitTrivially);
    exploitTrivially = new ExploitTrivially(name);
    AttackStep.allAttackSteps.remove(exploitWithEffort);
    exploitWithEffort = new ExploitWithEffort(name);
  }

  public HardwareVulnerability(String name) {
    super(name);
    assetClassName = "HardwareVulnerability";
    if (physicalAccessRequired != null) {
      AttackStep.allAttackSteps.remove(physicalAccessRequired.disable);
    }
    Defense.allDefenses.remove(physicalAccessRequired);
    physicalAccessRequired = new PhysicalAccessRequired(name, false);
    if (confidentialityImpactLimitations != null) {
      AttackStep.allAttackSteps.remove(confidentialityImpactLimitations.disable);
    }
    Defense.allDefenses.remove(confidentialityImpactLimitations);
    confidentialityImpactLimitations = new ConfidentialityImpactLimitations(name, false);
    if (availabilityImpactLimitations != null) {
      AttackStep.allAttackSteps.remove(availabilityImpactLimitations.disable);
    }
    Defense.allDefenses.remove(availabilityImpactLimitations);
    availabilityImpactLimitations = new AvailabilityImpactLimitations(name, false);
    if (integrityImpactLimitations != null) {
      AttackStep.allAttackSteps.remove(integrityImpactLimitations.disable);
    }
    Defense.allDefenses.remove(integrityImpactLimitations);
    integrityImpactLimitations = new IntegrityImpactLimitations(name, false);
    if (effortRequiredToExploit != null) {
      AttackStep.allAttackSteps.remove(effortRequiredToExploit.disable);
    }
    Defense.allDefenses.remove(effortRequiredToExploit);
    effortRequiredToExploit = new EffortRequiredToExploit(name, false);
    AttackStep.allAttackSteps.remove(physicalAccessAchieved);
    physicalAccessAchieved = new PhysicalAccessAchieved(name);
    AttackStep.allAttackSteps.remove(impact);
    impact = new Impact(name);
    AttackStep.allAttackSteps.remove(read);
    read = new Read(name);
    AttackStep.allAttackSteps.remove(modify);
    modify = new Modify(name);
    AttackStep.allAttackSteps.remove(deny);
    deny = new Deny(name);
    AttackStep.allAttackSteps.remove(attemptExploit);
    attemptExploit = new AttemptExploit(name);
    AttackStep.allAttackSteps.remove(exploitTrivially);
    exploitTrivially = new ExploitTrivially(name);
    AttackStep.allAttackSteps.remove(exploitWithEffort);
    exploitWithEffort = new ExploitWithEffort(name);
  }

  public HardwareVulnerability(boolean isNotPresentEnabled, boolean isPhysicalAccessRequiredEnabled,
      boolean isConfidentialityImpactLimitationsEnabled,
      boolean isAvailabilityImpactLimitationsEnabled, boolean isIntegrityImpactLimitationsEnabled,
      boolean isEffortRequiredToExploitEnabled) {
    this("Anonymous", isNotPresentEnabled, isPhysicalAccessRequiredEnabled, isConfidentialityImpactLimitationsEnabled, isAvailabilityImpactLimitationsEnabled, isIntegrityImpactLimitationsEnabled, isEffortRequiredToExploitEnabled);
  }

  public HardwareVulnerability() {
    this("Anonymous");
  }

  public void addHardware(Hardware hardware) {
    this.hardware = hardware;
    hardware.vulnerabilities.add(this);
  }

  @Override
  public String getAssociatedAssetClassName(String field) {
    if (field.equals("hardware")) {
      return Hardware.class.getName();
    }
    return "";
  }

  @Override
  public Set<Asset> getAssociatedAssets(String field) {
    Set<Asset> assets = new HashSet<>();
    if (field.equals("hardware")) {
      if (hardware != null) {
        assets.add(hardware);
      }
    }
    return assets;
  }

  @Override
  public Set<Asset> getAllAssociatedAssets() {
    Set<Asset> assets = new HashSet<>();
    if (hardware != null) {
      assets.add(hardware);
    }
    return assets;
  }

  public class PhysicalAccessRequired extends Defense {
    public PhysicalAccessRequired(String name) {
      this(name, false);
    }

    public PhysicalAccessRequired(String name, Boolean isEnabled) {
      super(name);
      defaultValue = isEnabled;
      disable = new Disable(name);
    }

    public class Disable extends AttackStepMin {
      private Set<AttackStep> _cacheChildrenPhysicalAccessRequired;

      public Disable(String name) {
        super(name);
      }

      @Override
      public void updateChildren(Set<AttackStep> attackSteps) {
        if (_cacheChildrenPhysicalAccessRequired == null) {
          _cacheChildrenPhysicalAccessRequired = new HashSet<>();
          _cacheChildrenPhysicalAccessRequired.add(physicalAccessAchieved);
        }
        for (AttackStep attackStep : _cacheChildrenPhysicalAccessRequired) {
          attackStep.updateTtc(this, ttc, attackSteps);
        }
      }

      @Override
      public String fullName() {
        return "HardwareVulnerability.physicalAccessRequired";
      }
    }
  }

  public class ConfidentialityImpactLimitations extends Defense {
    public ConfidentialityImpactLimitations(String name) {
      this(name, false);
    }

    public ConfidentialityImpactLimitations(String name, Boolean isEnabled) {
      super(name);
      defaultValue = isEnabled;
      disable = new Disable(name);
    }

    public class Disable extends AttackStepMin {
      private Set<AttackStep> _cacheChildrenConfidentialityImpactLimitations;

      public Disable(String name) {
        super(name);
      }

      @Override
      public void updateChildren(Set<AttackStep> attackSteps) {
        if (_cacheChildrenConfidentialityImpactLimitations == null) {
          _cacheChildrenConfidentialityImpactLimitations = new HashSet<>();
          _cacheChildrenConfidentialityImpactLimitations.add(read);
        }
        for (AttackStep attackStep : _cacheChildrenConfidentialityImpactLimitations) {
          attackStep.updateTtc(this, ttc, attackSteps);
        }
      }

      @Override
      public String fullName() {
        return "HardwareVulnerability.confidentialityImpactLimitations";
      }
    }
  }

  public class AvailabilityImpactLimitations extends Defense {
    public AvailabilityImpactLimitations(String name) {
      this(name, false);
    }

    public AvailabilityImpactLimitations(String name, Boolean isEnabled) {
      super(name);
      defaultValue = isEnabled;
      disable = new Disable(name);
    }

    public class Disable extends AttackStepMin {
      private Set<AttackStep> _cacheChildrenAvailabilityImpactLimitations;

      public Disable(String name) {
        super(name);
      }

      @Override
      public void updateChildren(Set<AttackStep> attackSteps) {
        if (_cacheChildrenAvailabilityImpactLimitations == null) {
          _cacheChildrenAvailabilityImpactLimitations = new HashSet<>();
          _cacheChildrenAvailabilityImpactLimitations.add(deny);
        }
        for (AttackStep attackStep : _cacheChildrenAvailabilityImpactLimitations) {
          attackStep.updateTtc(this, ttc, attackSteps);
        }
      }

      @Override
      public String fullName() {
        return "HardwareVulnerability.availabilityImpactLimitations";
      }
    }
  }

  public class IntegrityImpactLimitations extends Defense {
    public IntegrityImpactLimitations(String name) {
      this(name, false);
    }

    public IntegrityImpactLimitations(String name, Boolean isEnabled) {
      super(name);
      defaultValue = isEnabled;
      disable = new Disable(name);
    }

    public class Disable extends AttackStepMin {
      private Set<AttackStep> _cacheChildrenIntegrityImpactLimitations;

      public Disable(String name) {
        super(name);
      }

      @Override
      public void updateChildren(Set<AttackStep> attackSteps) {
        if (_cacheChildrenIntegrityImpactLimitations == null) {
          _cacheChildrenIntegrityImpactLimitations = new HashSet<>();
          _cacheChildrenIntegrityImpactLimitations.add(modify);
        }
        for (AttackStep attackStep : _cacheChildrenIntegrityImpactLimitations) {
          attackStep.updateTtc(this, ttc, attackSteps);
        }
      }

      @Override
      public String fullName() {
        return "HardwareVulnerability.integrityImpactLimitations";
      }
    }
  }

  public class EffortRequiredToExploit extends Defense {
    public EffortRequiredToExploit(String name) {
      this(name, false);
    }

    public EffortRequiredToExploit(String name, Boolean isEnabled) {
      super(name);
      defaultValue = isEnabled;
      disable = new Disable(name);
    }

    public class Disable extends AttackStepMin {
      private Set<AttackStep> _cacheChildrenEffortRequiredToExploit;

      public Disable(String name) {
        super(name);
      }

      @Override
      public void updateChildren(Set<AttackStep> attackSteps) {
        if (_cacheChildrenEffortRequiredToExploit == null) {
          _cacheChildrenEffortRequiredToExploit = new HashSet<>();
          _cacheChildrenEffortRequiredToExploit.add(exploitTrivially);
        }
        for (AttackStep attackStep : _cacheChildrenEffortRequiredToExploit) {
          attackStep.updateTtc(this, ttc, attackSteps);
        }
      }

      @Override
      public String fullName() {
        return "HardwareVulnerability.effortRequiredToExploit";
      }
    }
  }

  public class PhysicalAccessAchieved extends AttackStepMin {
    private Set<AttackStep> _cacheChildrenPhysicalAccessAchieved;

    private Set<AttackStep> _cacheParentPhysicalAccessAchieved;

    public PhysicalAccessAchieved(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenPhysicalAccessAchieved == null) {
        _cacheChildrenPhysicalAccessAchieved = new HashSet<>();
        if (HardwareVulnerability.this instanceof HardwareVulnerability) {
          _cacheChildrenPhysicalAccessAchieved.add(((org.mal_lang.redigoLang.test.HardwareVulnerability) HardwareVulnerability.this).abuse);
        }
      }
      for (AttackStep attackStep : _cacheChildrenPhysicalAccessAchieved) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentPhysicalAccessAchieved == null) {
        _cacheParentPhysicalAccessAchieved = new HashSet<>();
        if (hardware != null) {
          _cacheParentPhysicalAccessAchieved.add(hardware.hardwareModifications);
        }
        _cacheParentPhysicalAccessAchieved.add(physicalAccessRequired.disable);
      }
      for (AttackStep attackStep : _cacheParentPhysicalAccessAchieved) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("HardwareVulnerability.physicalAccessAchieved");
    }
  }

  public class Impact extends Vulnerability.Impact {
    private Set<AttackStep> _cacheChildrenImpact;

    public Impact(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenImpact == null) {
        _cacheChildrenImpact = new HashSet<>();
        _cacheChildrenImpact.add(read);
        _cacheChildrenImpact.add(modify);
        _cacheChildrenImpact.add(deny);
      }
      for (AttackStep attackStep : _cacheChildrenImpact) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("HardwareVulnerability.impact");
    }
  }

  public class Read extends AttackStepMax {
    private Set<AttackStep> _cacheChildrenRead;

    private Set<AttackStep> _cacheParentRead;

    public Read(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenRead == null) {
        _cacheChildrenRead = new HashSet<>();
        if (hardware != null) {
          _cacheChildrenRead.add(hardware.read);
        }
      }
      for (AttackStep attackStep : _cacheChildrenRead) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentRead == null) {
        _cacheParentRead = new HashSet<>();
        _cacheParentRead.add(confidentialityImpactLimitations.disable);
        _cacheParentRead.add(impact);
      }
      for (AttackStep attackStep : _cacheParentRead) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("HardwareVulnerability.read");
    }
  }

  public class Modify extends AttackStepMax {
    private Set<AttackStep> _cacheChildrenModify;

    private Set<AttackStep> _cacheParentModify;

    public Modify(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenModify == null) {
        _cacheChildrenModify = new HashSet<>();
        if (hardware != null) {
          _cacheChildrenModify.add(hardware.modify);
        }
      }
      for (AttackStep attackStep : _cacheChildrenModify) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentModify == null) {
        _cacheParentModify = new HashSet<>();
        _cacheParentModify.add(integrityImpactLimitations.disable);
        _cacheParentModify.add(impact);
      }
      for (AttackStep attackStep : _cacheParentModify) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("HardwareVulnerability.modify");
    }
  }

  public class Deny extends AttackStepMax {
    private Set<AttackStep> _cacheChildrenDeny;

    private Set<AttackStep> _cacheParentDeny;

    public Deny(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenDeny == null) {
        _cacheChildrenDeny = new HashSet<>();
        if (hardware != null) {
          _cacheChildrenDeny.add(hardware.deny);
        }
      }
      for (AttackStep attackStep : _cacheChildrenDeny) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentDeny == null) {
        _cacheParentDeny = new HashSet<>();
        _cacheParentDeny.add(availabilityImpactLimitations.disable);
        _cacheParentDeny.add(impact);
      }
      for (AttackStep attackStep : _cacheParentDeny) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("HardwareVulnerability.deny");
    }
  }

  public class AttemptExploit extends Vulnerability.AttemptExploit {
    private Set<AttackStep> _cacheChildrenAttemptExploit;

    public AttemptExploit(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenAttemptExploit == null) {
        _cacheChildrenAttemptExploit = new HashSet<>();
        _cacheChildrenAttemptExploit.add(exploitTrivially);
        _cacheChildrenAttemptExploit.add(exploitWithEffort);
      }
      for (AttackStep attackStep : _cacheChildrenAttemptExploit) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("HardwareVulnerability.attemptExploit");
    }
  }

  public class ExploitTrivially extends AttackStepMax {
    private Set<AttackStep> _cacheChildrenExploitTrivially;

    private Set<AttackStep> _cacheParentExploitTrivially;

    public ExploitTrivially(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenExploitTrivially == null) {
        _cacheChildrenExploitTrivially = new HashSet<>();
        if (HardwareVulnerability.this instanceof HardwareVulnerability) {
          _cacheChildrenExploitTrivially.add(((org.mal_lang.redigoLang.test.HardwareVulnerability) HardwareVulnerability.this).exploit);
        }
      }
      for (AttackStep attackStep : _cacheChildrenExploitTrivially) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentExploitTrivially == null) {
        _cacheParentExploitTrivially = new HashSet<>();
        _cacheParentExploitTrivially.add(effortRequiredToExploit.disable);
        _cacheParentExploitTrivially.add(attemptExploit);
      }
      for (AttackStep attackStep : _cacheParentExploitTrivially) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("HardwareVulnerability.exploitTrivially");
    }
  }

  public class ExploitWithEffort extends AttackStepMax {
    private Set<AttackStep> _cacheChildrenExploitWithEffort;

    private Set<AttackStep> _cacheParentExploitWithEffort;

    public ExploitWithEffort(String name) {
      super(name);
    }

    @Override
    public void updateChildren(Set<AttackStep> attackSteps) {
      if (_cacheChildrenExploitWithEffort == null) {
        _cacheChildrenExploitWithEffort = new HashSet<>();
        if (HardwareVulnerability.this instanceof HardwareVulnerability) {
          _cacheChildrenExploitWithEffort.add(((org.mal_lang.redigoLang.test.HardwareVulnerability) HardwareVulnerability.this).exploit);
        }
      }
      for (AttackStep attackStep : _cacheChildrenExploitWithEffort) {
        attackStep.updateTtc(this, ttc, attackSteps);
      }
    }

    @Override
    public void setExpectedParents() {
      super.setExpectedParents();
      if (_cacheParentExploitWithEffort == null) {
        _cacheParentExploitWithEffort = new HashSet<>();
        _cacheParentExploitWithEffort.add(attemptExploit);
      }
      for (AttackStep attackStep : _cacheParentExploitWithEffort) {
        addExpectedParent(attackStep);
      }
    }

    @Override
    public double localTtc() {
      return ttcHashMap.get("HardwareVulnerability.exploitWithEffort");
    }
  }
}
